<!DOCTYPE html>

<html>
<head>
<meta content="text/html; charset=UTF-8" http-equiv="Content-Type">

<title>class Concurrent::Promise - concurrent-ruby-1.0.2 Documentation</title>

<link type="text/css" media="screen" href="../rdoc.css" rel="stylesheet">

<script type="text/javascript">
  var rdoc_rel_prefix = "../";
</script>

<script type="text/javascript" charset="utf-8" src="../js/jquery.js"></script>
<script type="text/javascript" charset="utf-8" src="../js/navigation.js"></script>
<script type="text/javascript" charset="utf-8" src="../js/search_index.js"></script>
<script type="text/javascript" charset="utf-8" src="../js/search.js"></script>
<script type="text/javascript" charset="utf-8" src="../js/searcher.js"></script>
<script type="text/javascript" charset="utf-8" src="../js/darkfish.js"></script>


<body id="top" class="class">
<nav id="metadata">
  <nav id="home-section" class="section">
  <h3 class="section-header">
    <a href="../index.html">Home</a>
    <a href="../table_of_contents.html#classes">Classes</a>
    <a href="../table_of_contents.html#methods">Methods</a>
  </h3>
</nav>


  <nav id="search-section" class="section project-section" class="initially-hidden">
  <form action="#" method="get" accept-charset="utf-8">
    <h3 class="section-header">
      <input type="text" name="search" placeholder="Search" id="search-field"
             title="Type to search, Up and Down to navigate, Enter to load">
    </h3>
  </form>

  <ul id="search-results" class="initially-hidden"></ul>
</nav>


  

  <div id="file-metadata">
    <nav id="file-list-section" class="section">
  <h3 class="section-header">Defined In</h3>
  <ul>
    <li>lib/concurrent/promise.rb
  </ul>
</nav>

    
  </div>

  <div id="class-metadata">
    
    <nav id="parent-class-section" class="section">
  <h3 class="section-header">Parent</h3>
  
  <p class="link"><a href="IVar.html">Concurrent::IVar</a>
  
</nav>

    
    
    <!-- Method Quickref -->
<nav id="method-list-section" class="section">
  <h3 class="section-header">Methods</h3>

  <ul class="link-list">
    
    <li ><a href="#method-c-aggregate">::aggregate</a>
    
    <li ><a href="#method-c-all-3F">::all?</a>
    
    <li ><a href="#method-c-any-3F">::any?</a>
    
    <li ><a href="#method-c-execute">::execute</a>
    
    <li ><a href="#method-c-fulfill">::fulfill</a>
    
    <li class="calls-super" ><a href="#method-c-new">::new</a>
    
    <li ><a href="#method-c-reject">::reject</a>
    
    <li ><a href="#method-c-zip">::zip</a>
    
    <li ><a href="#method-i-catch">#catch</a>
    
    <li ><a href="#method-i-complete">#complete</a>
    
    <li ><a href="#method-i-execute">#execute</a>
    
    <li ><a href="#method-i-fail">#fail</a>
    
    <li ><a href="#method-i-flat_map">#flat_map</a>
    
    <li ><a href="#method-i-notify_child">#notify_child</a>
    
    <li class="calls-super" ><a href="#method-i-ns_initialize">#ns_initialize</a>
    
    <li ><a href="#method-i-on_error">#on_error</a>
    
    <li ><a href="#method-i-on_fulfill">#on_fulfill</a>
    
    <li ><a href="#method-i-on_reject">#on_reject</a>
    
    <li ><a href="#method-i-on_success">#on_success</a>
    
    <li ><a href="#method-i-realize">#realize</a>
    
    <li ><a href="#method-i-rescue">#rescue</a>
    
    <li ><a href="#method-i-set">#set</a>
    
    <li ><a href="#method-i-set_pending">#set_pending</a>
    
    <li ><a href="#method-i-set_state-21">#set_state!</a>
    
    <li ><a href="#method-i-synchronized_set_state-21">#synchronized_set_state!</a>
    
    <li ><a href="#method-i-then">#then</a>
    
    <li ><a href="#method-i-zip">#zip</a>
    
  </ul>
</nav>

  </div>

  <div id="project-metadata">
    <nav id="fileindex-section" class="section project-section">
  <h3 class="section-header">Pages</h3>

  <ul>
  
    <li class="file"><a href="../CHANGELOG_md.html">CHANGELOG</a>
  
    <li class="file"><a href="../LICENSE_txt.html">LICENSE</a>
  
    <li class="file"><a href="../README_md.html">README</a>
  
  </ul>
</nav>

    <nav id="classindex-section" class="section project-section">
  <h3 class="section-header">Class and Module Index</h3>

  <ul class="link-list">
  
    <li><a href="../Concurrent.html">Concurrent</a>
  
    <li><a href="../Concurrent/AbstractExchanger.html">Concurrent::AbstractExchanger</a>
  
    <li><a href="../Concurrent/AbstractExecutorService.html">Concurrent::AbstractExecutorService</a>
  
    <li><a href="../Concurrent/AbstractThreadLocalVar.html">Concurrent::AbstractThreadLocalVar</a>
  
    <li><a href="../Concurrent/Agent.html">Concurrent::Agent</a>
  
    <li><a href="../Concurrent/Agent/Error.html">Concurrent::Agent::Error</a>
  
    <li><a href="../Concurrent/Agent/ValidationError.html">Concurrent::Agent::ValidationError</a>
  
    <li><a href="../Concurrent/Array.html">Concurrent::Array</a>
  
    <li><a href="../Concurrent/Async.html">Concurrent::Async</a>
  
    <li><a href="../Concurrent/Async/AsyncDelegator.html">Concurrent::Async::AsyncDelegator</a>
  
    <li><a href="../Concurrent/Async/AwaitDelegator.html">Concurrent::Async::AwaitDelegator</a>
  
    <li><a href="../Concurrent/Async/ClassMethods.html">Concurrent::Async::ClassMethods</a>
  
    <li><a href="../Concurrent/AtExitImplementation.html">Concurrent::AtExitImplementation</a>
  
    <li><a href="../Concurrent/Atom.html">Concurrent::Atom</a>
  
    <li><a href="../Concurrent/AtomicBoolean.html">Concurrent::AtomicBoolean</a>
  
    <li><a href="../Concurrent/AtomicDirectUpdate.html">Concurrent::AtomicDirectUpdate</a>
  
    <li><a href="../Concurrent/AtomicFixnum.html">Concurrent::AtomicFixnum</a>
  
    <li><a href="../Concurrent/AtomicNumericCompareAndSetWrapper.html">Concurrent::AtomicNumericCompareAndSetWrapper</a>
  
    <li><a href="../Concurrent/AtomicReference.html">Concurrent::AtomicReference</a>
  
    <li><a href="../Concurrent/CAtomicReference.html">Concurrent::CAtomicReference</a>
  
    <li><a href="../Concurrent/CachedThreadPool.html">Concurrent::CachedThreadPool</a>
  
    <li><a href="../Concurrent/Collection.html">Concurrent::Collection</a>
  
    <li><a href="../Concurrent/Collection/AtomicReferenceMapBackend.html">Concurrent::Collection::AtomicReferenceMapBackend</a>
  
    <li><a href="../Concurrent/Collection/AtomicReferenceMapBackend/Node.html">Concurrent::Collection::AtomicReferenceMapBackend::Node</a>
  
    <li><a href="../Concurrent/Collection/AtomicReferenceMapBackend/Table.html">Concurrent::Collection::AtomicReferenceMapBackend::Table</a>
  
    <li><a href="../Concurrent/Collection/CopyOnNotifyObserverSet.html">Concurrent::Collection::CopyOnNotifyObserverSet</a>
  
    <li><a href="../Concurrent/Collection/CopyOnWriteObserverSet.html">Concurrent::Collection::CopyOnWriteObserverSet</a>
  
    <li><a href="../Concurrent/Collection/JavaNonConcurrentPriorityQueue.html">Concurrent::Collection::JavaNonConcurrentPriorityQueue</a>
  
    <li><a href="../Concurrent/Collection/MriMapBackend.html">Concurrent::Collection::MriMapBackend</a>
  
    <li><a href="../Concurrent/Collection/NonConcurrentMapBackend.html">Concurrent::Collection::NonConcurrentMapBackend</a>
  
    <li><a href="../Concurrent/Collection/NonConcurrentPriorityQueue.html">Concurrent::Collection::NonConcurrentPriorityQueue</a>
  
    <li><a href="../Concurrent/Collection/RubyNonConcurrentPriorityQueue.html">Concurrent::Collection::RubyNonConcurrentPriorityQueue</a>
  
    <li><a href="../Concurrent/Collection/SynchronizedMapBackend.html">Concurrent::Collection::SynchronizedMapBackend</a>
  
    <li><a href="../Concurrent/Concern.html">Concurrent::Concern</a>
  
    <li><a href="../Concurrent/Concern/Deprecation.html">Concurrent::Concern::Deprecation</a>
  
    <li><a href="../Concurrent/Concern/Dereferenceable.html">Concurrent::Concern::Dereferenceable</a>
  
    <li><a href="../Concurrent/Concern/Logging.html">Concurrent::Concern::Logging</a>
  
    <li><a href="../Concurrent/Concern/Obligation.html">Concurrent::Concern::Obligation</a>
  
    <li><a href="../Concurrent/Concern/Observable.html">Concurrent::Concern::Observable</a>
  
    <li><a href="../Concurrent/ConcurrentUpdateError.html">Concurrent::ConcurrentUpdateError</a>
  
    <li><a href="../Concurrent/CountDownLatch.html">Concurrent::CountDownLatch</a>
  
    <li><a href="../Concurrent/CyclicBarrier.html">Concurrent::CyclicBarrier</a>
  
    <li><a href="../Concurrent/Delay.html">Concurrent::Delay</a>
  
    <li><a href="../Concurrent/DependencyCounter.html">Concurrent::DependencyCounter</a>
  
    <li><a href="../Concurrent/Edge.html">Concurrent::Edge</a>
  
    <li><a href="../Concurrent/Event.html">Concurrent::Event</a>
  
    <li><a href="../Concurrent/Exchanger.html">Concurrent::Exchanger</a>
  
    <li><a href="../Concurrent/ExecutorService.html">Concurrent::ExecutorService</a>
  
    <li><a href="../Concurrent/FixedThreadPool.html">Concurrent::FixedThreadPool</a>
  
    <li><a href="../Concurrent/Future.html">Concurrent::Future</a>
  
    <li><a href="../Concurrent/Hash.html">Concurrent::Hash</a>
  
    <li><a href="../Concurrent/IVar.html">Concurrent::IVar</a>
  
    <li><a href="../Concurrent/ImmediateExecutor.html">Concurrent::ImmediateExecutor</a>
  
    <li><a href="../Concurrent/ImmutableStruct.html">Concurrent::ImmutableStruct</a>
  
    <li><a href="../Concurrent/IndirectImmediateExecutor.html">Concurrent::IndirectImmediateExecutor</a>
  
    <li><a href="../Concurrent/JavaAtomicReference.html">Concurrent::JavaAtomicReference</a>
  
    <li><a href="../Concurrent/JavaCountDownLatch.html">Concurrent::JavaCountDownLatch</a>
  
    <li><a href="../Concurrent/JavaExchanger.html">Concurrent::JavaExchanger</a>
  
    <li><a href="../Concurrent/JavaExecutorService.html">Concurrent::JavaExecutorService</a>
  
    <li><a href="../Concurrent/JavaExecutorService/Job.html">Concurrent::JavaExecutorService::Job</a>
  
    <li><a href="../Concurrent/JavaSingleThreadExecutor.html">Concurrent::JavaSingleThreadExecutor</a>
  
    <li><a href="../Concurrent/JavaThreadLocalVar.html">Concurrent::JavaThreadLocalVar</a>
  
    <li><a href="../Concurrent/JavaThreadPoolExecutor.html">Concurrent::JavaThreadPoolExecutor</a>
  
    <li><a href="../Concurrent/LazyRegister.html">Concurrent::LazyRegister</a>
  
    <li><a href="../Concurrent/MVar.html">Concurrent::MVar</a>
  
    <li><a href="../Concurrent/Map.html">Concurrent::Map</a>
  
    <li><a href="../Concurrent/Maybe.html">Concurrent::Maybe</a>
  
    <li><a href="../Concurrent/MutableStruct.html">Concurrent::MutableStruct</a>
  
    <li><a href="../Concurrent/MutexAtomicBoolean.html">Concurrent::MutexAtomicBoolean</a>
  
    <li><a href="../Concurrent/MutexAtomicFixnum.html">Concurrent::MutexAtomicFixnum</a>
  
    <li><a href="../Concurrent/MutexAtomicReference.html">Concurrent::MutexAtomicReference</a>
  
    <li><a href="../Concurrent/MutexCountDownLatch.html">Concurrent::MutexCountDownLatch</a>
  
    <li><a href="../Concurrent/MutexSemaphore.html">Concurrent::MutexSemaphore</a>
  
    <li><a href="../Concurrent/Options.html">Concurrent::Options</a>
  
    <li><a href="../Concurrent/Process.html">Concurrent::Process</a>
  
    <li><a href="../Concurrent/Promise.html">Concurrent::Promise</a>
  
    <li><a href="../Concurrent/RbxAtomicReference.html">Concurrent::RbxAtomicReference</a>
  
    <li><a href="../Concurrent/ReadWriteLock.html">Concurrent::ReadWriteLock</a>
  
    <li><a href="../Concurrent/ReentrantReadWriteLock.html">Concurrent::ReentrantReadWriteLock</a>
  
    <li><a href="../Concurrent/RubyExchanger.html">Concurrent::RubyExchanger</a>
  
    <li><a href="../Concurrent/RubyExchanger/Node.html">Concurrent::RubyExchanger::Node</a>
  
    <li><a href="../Concurrent/RubyExecutorService.html">Concurrent::RubyExecutorService</a>
  
    <li><a href="../Concurrent/RubySingleThreadExecutor.html">Concurrent::RubySingleThreadExecutor</a>
  
    <li><a href="../Concurrent/RubyThreadLocalVar.html">Concurrent::RubyThreadLocalVar</a>
  
    <li><a href="../Concurrent/RubyThreadPoolExecutor.html">Concurrent::RubyThreadPoolExecutor</a>
  
    <li><a href="../Concurrent/RubyThreadPoolExecutor/Worker.html">Concurrent::RubyThreadPoolExecutor::Worker</a>
  
    <li><a href="../Concurrent/SafeTaskExecutor.html">Concurrent::SafeTaskExecutor</a>
  
    <li><a href="../Concurrent/ScheduledTask.html">Concurrent::ScheduledTask</a>
  
    <li><a href="../Concurrent/Semaphore.html">Concurrent::Semaphore</a>
  
    <li><a href="../Concurrent/SerialExecutorService.html">Concurrent::SerialExecutorService</a>
  
    <li><a href="../Concurrent/SerializedExecution.html">Concurrent::SerializedExecution</a>
  
    <li><a href="../Concurrent/SerializedExecutionDelegator.html">Concurrent::SerializedExecutionDelegator</a>
  
    <li><a href="../Concurrent/SettableStruct.html">Concurrent::SettableStruct</a>
  
    <li><a href="../Concurrent/SimpleExecutorService.html">Concurrent::SimpleExecutorService</a>
  
    <li><a href="../Concurrent/SingleThreadExecutor.html">Concurrent::SingleThreadExecutor</a>
  
    <li><a href="../Concurrent/Synchronization.html">Concurrent::Synchronization</a>
  
    <li><a href="../Concurrent/Synchronization/AbstractLockableObject.html">Concurrent::Synchronization::AbstractLockableObject</a>
  
    <li><a href="../Concurrent/Synchronization/AbstractObject.html">Concurrent::Synchronization::AbstractObject</a>
  
    <li><a href="../Concurrent/Synchronization/AbstractStruct.html">Concurrent::Synchronization::AbstractStruct</a>
  
    <li><a href="../Concurrent/Synchronization/Condition.html">Concurrent::Synchronization::Condition</a>
  
    <li><a href="../Concurrent/Synchronization/JRubyAttrVolatile.html">Concurrent::Synchronization::JRubyAttrVolatile</a>
  
    <li><a href="../Concurrent/Synchronization/JRubyAttrVolatile/ClassMethods.html">Concurrent::Synchronization::JRubyAttrVolatile::ClassMethods</a>
  
    <li><a href="../Concurrent/Synchronization/JRubyLockableObject.html">Concurrent::Synchronization::JRubyLockableObject</a>
  
    <li><a href="../Concurrent/Synchronization/JRubyObject.html">Concurrent::Synchronization::JRubyObject</a>
  
    <li><a href="../Concurrent/Synchronization/Lock.html">Concurrent::Synchronization::Lock</a>
  
    <li><a href="../Concurrent/Synchronization/LockableObject.html">Concurrent::Synchronization::LockableObject</a>
  
    <li><a href="../Concurrent/Synchronization/MriAttrVolatile.html">Concurrent::Synchronization::MriAttrVolatile</a>
  
    <li><a href="../Concurrent/Synchronization/MriAttrVolatile/ClassMethods.html">Concurrent::Synchronization::MriAttrVolatile::ClassMethods</a>
  
    <li><a href="../Concurrent/Synchronization/MriLockableObject.html">Concurrent::Synchronization::MriLockableObject</a>
  
    <li><a href="../Concurrent/Synchronization/MriMonitorLockableObject.html">Concurrent::Synchronization::MriMonitorLockableObject</a>
  
    <li><a href="../Concurrent/Synchronization/MriMutexLockableObject.html">Concurrent::Synchronization::MriMutexLockableObject</a>
  
    <li><a href="../Concurrent/Synchronization/MriObject.html">Concurrent::Synchronization::MriObject</a>
  
    <li><a href="../Concurrent/Synchronization/Object.html">Concurrent::Synchronization::Object</a>
  
    <li><a href="../Concurrent/Synchronization/RbxAttrVolatile.html">Concurrent::Synchronization::RbxAttrVolatile</a>
  
    <li><a href="../Concurrent/Synchronization/RbxAttrVolatile/ClassMethods.html">Concurrent::Synchronization::RbxAttrVolatile::ClassMethods</a>
  
    <li><a href="../Concurrent/Synchronization/RbxLockableObject.html">Concurrent::Synchronization::RbxLockableObject</a>
  
    <li><a href="../Concurrent/Synchronization/RbxObject.html">Concurrent::Synchronization::RbxObject</a>
  
    <li><a href="../Concurrent/Synchronization/TruffleAttrVolatile.html">Concurrent::Synchronization::TruffleAttrVolatile</a>
  
    <li><a href="../Concurrent/Synchronization/TruffleAttrVolatile/ClassMethods.html">Concurrent::Synchronization::TruffleAttrVolatile::ClassMethods</a>
  
    <li><a href="../Concurrent/Synchronization/TruffleLockableObject.html">Concurrent::Synchronization::TruffleLockableObject</a>
  
    <li><a href="../Concurrent/Synchronization/TruffleObject.html">Concurrent::Synchronization::TruffleObject</a>
  
    <li><a href="../Concurrent/SynchronizedDelegator.html">Concurrent::SynchronizedDelegator</a>
  
    <li><a href="../Concurrent/TVar.html">Concurrent::TVar</a>
  
    <li><a href="../Concurrent/ThreadLocalVar.html">Concurrent::ThreadLocalVar</a>
  
    <li><a href="../Concurrent/ThreadPoolExecutor.html">Concurrent::ThreadPoolExecutor</a>
  
    <li><a href="../Concurrent/ThreadSafe.html">Concurrent::ThreadSafe</a>
  
    <li><a href="../Concurrent/ThreadSafe/Util.html">Concurrent::ThreadSafe::Util</a>
  
    <li><a href="../Concurrent/ThreadSafe/Util/Adder.html">Concurrent::ThreadSafe::Util::Adder</a>
  
    <li><a href="../Concurrent/ThreadSafe/Util/CheapLockable.html">Concurrent::ThreadSafe::Util::CheapLockable</a>
  
    <li><a href="../Concurrent/ThreadSafe/Util/PowerOfTwoTuple.html">Concurrent::ThreadSafe::Util::PowerOfTwoTuple</a>
  
    <li><a href="../Concurrent/ThreadSafe/Util/Striped64.html">Concurrent::ThreadSafe::Util::Striped64</a>
  
    <li><a href="../Concurrent/ThreadSafe/Util/Striped64/Cell.html">Concurrent::ThreadSafe::Util::Striped64::Cell</a>
  
    <li><a href="../Concurrent/ThreadSafe/Util/Volatile.html">Concurrent::ThreadSafe::Util::Volatile</a>
  
    <li><a href="../Concurrent/ThreadSafe/Util/XorShiftRandom.html">Concurrent::ThreadSafe::Util::XorShiftRandom</a>
  
    <li><a href="../Concurrent/TimerSet.html">Concurrent::TimerSet</a>
  
    <li><a href="../Concurrent/TimerTask.html">Concurrent::TimerTask</a>
  
    <li><a href="../Concurrent/Transaction.html">Concurrent::Transaction</a>
  
    <li><a href="../Concurrent/Tuple.html">Concurrent::Tuple</a>
  
    <li><a href="../Concurrent/Utility.html">Concurrent::Utility</a>
  
    <li><a href="../Concurrent/Utility/EngineDetector.html">Concurrent::Utility::EngineDetector</a>
  
    <li><a href="../Concurrent/Utility/NativeExtensionLoader.html">Concurrent::Utility::NativeExtensionLoader</a>
  
    <li><a href="../Concurrent/Utility/ProcessorCounter.html">Concurrent::Utility::ProcessorCounter</a>
  
  </ul>
</nav>

  </div>
</nav>

<div id="documentation">
  <h1 class="class">class Concurrent::Promise</h1>

  <div id="description" class="description">
    
<p>Promises are inspired by the JavaScript [Promises/A](<a
href="http://wiki.commonjs.org/wiki/Promises/A">wiki.commonjs.org/wiki/Promises/A</a>)
and [Promises/A+](<a
href="http://promises-aplus.github.io/promises-spec">promises-aplus.github.io/promises-spec</a>/)
specifications.</p>

<p>&gt; A promise represents the eventual value returned from the single &gt;
completion of an operation.</p>

<p>Promises are similar to futures and share many of the same behaviours.
Promises are far more robust, however. Promises can be chained in a tree
structure where each promise may have zero or more children. Promises are
chained using the `then` method. The result of a call to `then` is always
another promise. Promises are resolved asynchronously (with respect to the
main thread) but in a strict order: parents are guaranteed to be resolved
before their children, children before their younger siblings. The `then`
method takes two parameters: an optional block to be executed upon parent
resolution and an optional callable to be executed upon parent failure. The
result of each promise is passed to each of its children upon resolution.
When a promise is rejected all its children will be summarily rejected and
will receive the reason.</p>

<p>Promises have several possible states: <strong>:unscheduled</strong>,
<strong>:pending</strong>, <strong>:processing</strong>,
<strong>:rejected</strong>, or <strong>:fulfilled</strong>. These are also
aggregated as `#incomplete?` and `#complete?`. When a <a
href="Promise.html">Promise</a> is created it is set to
<strong>:unscheduled</strong>. Once the `#execute` method is called the
state becomes <strong>:pending</strong>. Once a job is pulled from the
thread pool&#39;s queue and is given to a thread for processing (often
immediately upon `#post`) the state becomes <strong>:processing</strong>.
The future will remain in this state until processing is complete. A future
that is in the <strong>:unscheduled</strong>, <strong>:pending</strong>, or
<strong>:processing</strong> is considered `#incomplete?`. A `#complete?`
<a href="Promise.html">Promise</a> is either <strong>:rejected</strong>,
indicating that an exception was thrown during processing, or
<strong>:fulfilled</strong>, indicating success. If a <a
href="Promise.html">Promise</a> is <strong>:fulfilled</strong> its `#value`
will be updated to reflect the result of the operation. If
<strong>:rejected</strong> the `reason` will be updated with a reference to
the thrown exception. The predicate methods `#unscheduled?`, `#pending?`,
`#rejected?`, and `#fulfilled?` can be called at any time to obtain the
state of the <a href="Promise.html">Promise</a>, as can the `#state`
method, which returns a symbol.</p>

<p>Retrieving the value of a promise is done through the `value` (alias:
`deref`) method. Obtaining the value of a promise is a potentially blocking
operation. When a promise is <strong>rejected</strong> a call to `value`
will return `nil` immediately. When a promise is <strong>fulfilled</strong>
a call to `value` will immediately return the current value. When a promise
is <strong>pending</strong> a call to `value` will block until the promise
is either <strong>rejected</strong> or <strong>fulfilled</strong>. A
<strong>timeout</strong> value can be passed to `value` to limit how long
the call will block. If `nil` the call will block indefinitely. If `0` the
call will not block. Any other integer or float value will indicate the
maximum number of seconds to block.</p>

<p>Promises run on the global thread pool.</p>

<p>@!macro copy_options</p>

<p>### Examples</p>

<p>Start by requiring promises</p>

<p>“`ruby require &#39;concurrent&#39; “`</p>

<p>Then create one</p>

<p>“`ruby p = <a href="Promise.html#method-i-execute">#execute</a> do</p>

<pre>  # do something
  42
end</pre>

<p>“`</p>

<p>Promises can be chained using the `then` method. The `then` method accepts
a block, to be executed on fulfillment, and a callable argument to be
executed on rejection. The result of the each promise is passed as the
block argument to chained promises.</p>

<p>“`ruby p = <a href="Promise.html#method-c-new">::new</a>{10}.then{|x| x *
2}.then{|result| result - 10 }.execute “`</p>

<p>And so on, and so on, and so on…</p>

<p>“`ruby p = <a href="Promise.html#method-c-fulfill">::fulfill</a>.</p>

<pre class="ruby"><span class="ruby-keyword">then</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">result</span><span class="ruby-operator">|</span> <span class="ruby-identifier">result</span> <span class="ruby-operator">-</span> <span class="ruby-value">10</span> }.
<span class="ruby-identifier">then</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">result</span><span class="ruby-operator">|</span> <span class="ruby-identifier">result</span> <span class="ruby-operator">*</span> <span class="ruby-value">3</span> }.
<span class="ruby-identifier">then</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">result</span><span class="ruby-operator">|</span> <span class="ruby-identifier">result</span> <span class="ruby-operator">%</span> <span class="ruby-value">5</span> }.<span class="ruby-identifier">execute</span>
</pre>

<p>“`</p>

<p>The initial state of a newly created <a href="Promise.html">Promise</a>
depends on the state of its parent:</p>
<ul><li>
<p>if parent is <strong>unscheduled</strong> the child will be
<strong>unscheduled</strong></p>
</li><li>
<p>if parent is <strong>pending</strong> the child will be
<strong>pending</strong></p>
</li><li>
<p>if parent is <strong>fulfilled</strong> the child will be
<strong>pending</strong></p>
</li><li>
<p>if parent is <strong>rejected</strong> the child will be
<strong>pending</strong> (but will ultimately be <strong>rejected</strong>)</p>
</li></ul>

<p>Promises are executed asynchronously from the main thread. By the time a
child <a href="Promise.html">Promise</a> finishes nitialization it may be
in a different state that its parent (by the time a child is created its
parent may have completed execution and changed state). Despite being
asynchronous, however, the order of execution of <a
href="Promise.html">Promise</a> objects in a chain (or tree) is strictly
defined.</p>

<p>There are multiple ways to create and execute a new `Promise`. Both ways
provide identical behavior:</p>

<p>“`ruby # create, operate, then execute p1 = <a
href="Promise.html#method-c-new">::new</a>{ “Hello World!” } p1.state
#=&gt; :unscheduled p1.execute</p>

<p># create and immediately execute p2 = <a
href="Promise.html#method-c-new">::new</a>{ “Hello World!” }.execute</p>

<p># execute during creation p3 = <a
href="Promise.html#method-i-execute">#execute</a>{ “Hello World!” } “`</p>

<p>Once the `execute` method is called a `Promise` becomes `pending`:</p>

<p>“`ruby p = <a href="Promise.html#method-i-execute">#execute</a>{ “Hello,
world!” } p.state    #=&gt; :pending p.pending? #=&gt; true “`</p>

<p>Wait a little bit, and the promise will resolve and provide a value:</p>

<p>“`ruby p = <a href="Promise.html#method-i-execute">#execute</a>{ “Hello,
world!” } sleep(0.1)</p>

<p>p.state      #=&gt; :fulfilled p.fulfilled? #=&gt; true p.value      #=&gt;
“Hello, world!” “`</p>

<p>If an exception occurs, the promise will be rejected and will provide a
reason for the rejection:</p>

<p>“`ruby p = <a href="Promise.html#method-i-execute">#execute</a>{ raise
StandardError.new(“Here comes the Boom!”) } sleep(0.1)</p>

<p>p.state     #=&gt; :rejected p.rejected? #=&gt; true p.reason    #=&gt;
“#&lt;StandardError: Here comes the Boom!&gt;” “`</p>

<p>#### Rejection</p>

<p>When a promise is rejected all its children will be rejected and will
receive the rejection `reason` as the rejection callable parameter:</p>

<p>“`ruby p = [ <a href="Promise.html#method-i-execute">#execute</a>{
Thread.pass; raise StandardError } ]</p>

<p>c1 = p.then(Proc.new{ |reason| 42 }) c2 = p.then(Proc.new{ |reason| raise
&#39;Boom!&#39; })</p>

<p>sleep(0.1)</p>

<p>c1.state  #=&gt; :rejected c2.state  #=&gt; :rejected “`</p>

<p>Once a promise is rejected it will continue to accept children that will
receive immediately rejection (they will be executed asynchronously).</p>

<p>#### Aliases</p>

<p>The `then` method is the most generic alias: it accepts a block to be
executed upon parent fulfillment and a callable to be executed upon parent
rejection. At least one of them should be passed. The default block is `{
|result| result }` that fulfills the child with the parent value. The
default callable is `{ |reason| raise reason }` that rejects the child with
the parent reason.</p>
<ul><li>
<p>`on_success { |result| … }` is the same as `then {|result| … }`</p>
</li><li>
<p>`rescue { |reason| … }` is the same as `then(Proc.new { |reason| … } )`</p>
</li><li>
<p>`rescue` is aliased by `catch` and `on_error`</p>
</li></ul>

  </div><!-- description -->

  
  
  
  <section id="5Buntitled-5D" class="documentation-section">
    

    

    

    

    <!-- Methods -->
    
     <section id="public-class-5Buntitled-5D-method-details" class="method-section section">
      <h3 class="section-header">Public Class Methods</h3>

    
      <div id="method-c-all-3F" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">all?</span><span
            class="method-args">(*promises)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Aggregates a collection of promises and executes the `then` condition if
all aggregated promises succeed. Executes the `rescue` handler with a
`Concurrent::PromiseExecutionError` if any of the aggregated promises fail.
Upon execution will execute any of the aggregate promises that were not
already executed.</p>

<p>@!macro [attach] promise_self_aggregate</p>

<pre>The returned promise will not yet have been executed. Additional `#then`
and `#rescue` handlers may still be provided. Once the returned promise
is execute the aggregate promises will be also be executed (if they have
not been executed already). The results of the aggregate promises will
be checked upon completion. The necessary `#then` and `#rescue` blocks
on the aggregating promise will then be executed as appropriate. If the
`#rescue` handlers are executed the raises exception will be
`Concurrent::PromiseExecutionError`.

@param [Array] promises Zero or more promises to aggregate
@return [Promise] an unscheduled (not executed) promise that aggregates
  the promises given as arguments</pre>
          
          

          
          <div class="method-source-code" id="all-3F-source">
            <pre><span class="ruby-comment"># File lib/concurrent/promise.rb, line 427</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">all?</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">promises</span>)
  <span class="ruby-identifier">aggregate</span>(<span class="ruby-value">:all?</span>, <span class="ruby-operator">*</span><span class="ruby-identifier">promises</span>)
<span class="ruby-keyword">end</span></pre>
          </div><!-- all-3F-source -->
          
        </div>

        

        
      </div><!-- all-3F-method -->

    
      <div id="method-c-any-3F" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">any?</span><span
            class="method-args">(*promises)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Aggregates a collection of promises and executes the `then` condition if
any aggregated promises succeed. Executes the `rescue` handler with a
`Concurrent::PromiseExecutionError` if any of the aggregated promises fail.
Upon execution will execute any of the aggregate promises that were not
already executed.</p>

<p>@!macro promise_self_aggregate</p>
          
          

          
          <div class="method-source-code" id="any-3F-source">
            <pre><span class="ruby-comment"># File lib/concurrent/promise.rb, line 438</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">any?</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">promises</span>)
  <span class="ruby-identifier">aggregate</span>(<span class="ruby-value">:any?</span>, <span class="ruby-operator">*</span><span class="ruby-identifier">promises</span>)
<span class="ruby-keyword">end</span></pre>
          </div><!-- any-3F-source -->
          
        </div>

        

        
      </div><!-- any-3F-method -->

    
      <div id="method-c-execute" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">execute</span><span
            class="method-args">(opts = {}, &block)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Create a new `Promise` object with the given block, execute it, and return
the `:pending` object.</p>

<p>@!macro executor_and_deref_options</p>

<p>@!macro promise_init_options</p>

<p>@return [Promise] the newly created `Promise` in the `:pending` state</p>

<p>@raise [ArgumentError] if no block is given</p>

<p>@example</p>

<pre class="ruby"><span class="ruby-identifier">promise</span> = <span class="ruby-constant">Concurrent</span><span class="ruby-operator">::</span><span class="ruby-constant">Promise</span>.<span class="ruby-identifier">execute</span>{ <span class="ruby-identifier">sleep</span>(<span class="ruby-value">1</span>); <span class="ruby-value">42</span> }
<span class="ruby-identifier">promise</span>.<span class="ruby-identifier">state</span> <span class="ruby-comment">#=&gt; :pending</span>
</pre>
          
          

          
          <div class="method-source-code" id="execute-source">
            <pre><span class="ruby-comment"># File lib/concurrent/promise.rb, line 294</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">execute</span>(<span class="ruby-identifier">opts</span> = {}, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>)
  <span class="ruby-identifier">new</span>(<span class="ruby-identifier">opts</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>).<span class="ruby-identifier">execute</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- execute-source -->
          
        </div>

        

        
      </div><!-- execute-method -->

    
      <div id="method-c-fulfill" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">fulfill</span><span
            class="method-args">(value, opts = {})</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Create a new `Promise` and fulfill it immediately.</p>

<p>@!macro executor_and_deref_options</p>

<p>@!macro promise_init_options</p>

<p>@raise [ArgumentError] if no block is given</p>

<p>@return [Promise] the newly created `Promise`</p>
          
          

          
          <div class="method-source-code" id="fulfill-source">
            <pre><span class="ruby-comment"># File lib/concurrent/promise.rb, line 223</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">fulfill</span>(<span class="ruby-identifier">value</span>, <span class="ruby-identifier">opts</span> = {})
  <span class="ruby-constant">Promise</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">opts</span>).<span class="ruby-identifier">tap</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">p</span><span class="ruby-operator">|</span> <span class="ruby-identifier">p</span>.<span class="ruby-identifier">send</span>(<span class="ruby-value">:synchronized_set_state!</span>, <span class="ruby-keyword">true</span>, <span class="ruby-identifier">value</span>, <span class="ruby-keyword">nil</span>) }
<span class="ruby-keyword">end</span></pre>
          </div><!-- fulfill-source -->
          
        </div>

        

        
      </div><!-- fulfill-method -->

    
      <div id="method-c-new" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">new</span><span
            class="method-args">(opts = {}, &block)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Initialize a new <a href="Promise.html">Promise</a> with the provided
options.</p>

<p>@!macro executor_and_deref_options</p>

<p>@!macro [attach] promise_init_options</p>

<pre>@option opts [Promise] :parent the parent `Promise` when building a chain/tree
@option opts [Proc] :on_fulfill fulfillment handler
@option opts [Proc] :on_reject rejection handler
@option opts [object, Array] :args zero or more arguments to be passed
 the task block on execution</pre>

<p>@yield The block operation to be performed asynchronously.</p>

<p>@raise [ArgumentError] if no block is given</p>

<p>@see <a
href="http://wiki.commonjs.org/wiki/Promises/A">wiki.commonjs.org/wiki/Promises/A</a>
@see <a
href="http://promises-aplus.github.io/promises-spec">promises-aplus.github.io/promises-spec</a>/</p>
          
          
            <div class="method-calls-super">
              Calls superclass method
              <a href="IVar.html#method-c-new">Concurrent::IVar.new</a>
            </div>
          

          
          <div class="method-source-code" id="new-source">
            <pre><span class="ruby-comment"># File lib/concurrent/promise.rb, line 209</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">initialize</span>(<span class="ruby-identifier">opts</span> = {}, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>)
  <span class="ruby-identifier">opts</span>.<span class="ruby-identifier">delete_if</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">k</span>, <span class="ruby-identifier">v</span><span class="ruby-operator">|</span> <span class="ruby-identifier">v</span>.<span class="ruby-identifier">nil?</span> }
  <span class="ruby-keyword">super</span>(<span class="ruby-constant">NULL</span>, <span class="ruby-identifier">opts</span>.<span class="ruby-identifier">merge</span>(<span class="ruby-identifier">__promise_body_from_block__</span><span class="ruby-operator">:</span> <span class="ruby-identifier">block</span>), <span class="ruby-operator">&amp;</span><span class="ruby-keyword">nil</span>)
<span class="ruby-keyword">end</span></pre>
          </div><!-- new-source -->
          
        </div>

        

        
      </div><!-- new-method -->

    
      <div id="method-c-reject" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">reject</span><span
            class="method-args">(reason, opts = {})</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Create a new `Promise` and reject it immediately.</p>

<p>@!macro executor_and_deref_options</p>

<p>@!macro promise_init_options</p>

<p>@raise [ArgumentError] if no block is given</p>

<p>@return [Promise] the newly created `Promise`</p>
          
          

          
          <div class="method-source-code" id="reject-source">
            <pre><span class="ruby-comment"># File lib/concurrent/promise.rb, line 236</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">reject</span>(<span class="ruby-identifier">reason</span>, <span class="ruby-identifier">opts</span> = {})
  <span class="ruby-constant">Promise</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">opts</span>).<span class="ruby-identifier">tap</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">p</span><span class="ruby-operator">|</span> <span class="ruby-identifier">p</span>.<span class="ruby-identifier">send</span>(<span class="ruby-value">:synchronized_set_state!</span>, <span class="ruby-keyword">false</span>, <span class="ruby-keyword">nil</span>, <span class="ruby-identifier">reason</span>) }
<span class="ruby-keyword">end</span></pre>
          </div><!-- reject-source -->
          
        </div>

        

        
      </div><!-- reject-method -->

    
      <div id="method-c-zip" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">zip</span><span
            class="method-args">(*promises)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Builds a promise that produces the result of promises in an <a
href="Array.html">Array</a> and fails if any of them fails.</p>

<p>@param [Array&lt;Promise&gt;] promises</p>

<p>@return [Promise&lt;Array&gt;]</p>
          
          

          
          <div class="method-source-code" id="zip-source">
            <pre><span class="ruby-comment"># File lib/concurrent/promise.rb, line 385</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">zip</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">promises</span>)
  <span class="ruby-identifier">zero</span> = <span class="ruby-identifier">fulfill</span>([], <span class="ruby-identifier">executor</span><span class="ruby-operator">:</span> <span class="ruby-constant">ImmediateExecutor</span>.<span class="ruby-identifier">new</span>)

  <span class="ruby-identifier">promises</span>.<span class="ruby-identifier">reduce</span>(<span class="ruby-identifier">zero</span>) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">p1</span>, <span class="ruby-identifier">p2</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">p1</span>.<span class="ruby-identifier">flat_map</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">results</span><span class="ruby-operator">|</span>
      <span class="ruby-identifier">p2</span>.<span class="ruby-identifier">then</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">next_result</span><span class="ruby-operator">|</span>
        <span class="ruby-identifier">results</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">next_result</span>
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- zip-source -->
          
        </div>

        

        
      </div><!-- zip-method -->

    
    </section><!-- public-class-method-details -->
  
     <section id="protected-class-5Buntitled-5D-method-details" class="method-section section">
      <h3 class="section-header">Protected Class Methods</h3>

    
      <div id="method-c-aggregate" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">aggregate</span><span
            class="method-args">(method, *promises)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Aggregate a collection of zero or more promises under a composite promise,
execute the aggregated promises and collect them into a standard Ruby
array, call the given Ruby `Ennnumerable` predicate (such as `any?`,
`all?`, `none?`, or `one?`) on the collection checking for the success or
failure of each, then executing the composite&#39;s `#then` handlers if the
predicate returns `true` or executing the composite&#39;s `#rescue`
handlers if the predicate returns false.</p>

<p>@!macro promise_self_aggregate</p>
          
          

          
          <div class="method-source-code" id="aggregate-source">
            <pre><span class="ruby-comment"># File lib/concurrent/promise.rb, line 468</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">aggregate</span>(<span class="ruby-identifier">method</span>, <span class="ruby-operator">*</span><span class="ruby-identifier">promises</span>)
  <span class="ruby-identifier">composite</span> = <span class="ruby-constant">Promise</span>.<span class="ruby-identifier">new</span> <span class="ruby-keyword">do</span>
    <span class="ruby-identifier">completed</span> = <span class="ruby-identifier">promises</span>.<span class="ruby-identifier">collect</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">promise</span><span class="ruby-operator">|</span>
      <span class="ruby-identifier">promise</span>.<span class="ruby-identifier">execute</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">promise</span>.<span class="ruby-identifier">unscheduled?</span>
      <span class="ruby-identifier">promise</span>.<span class="ruby-identifier">wait</span>
      <span class="ruby-identifier">promise</span>
    <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">unless</span> <span class="ruby-identifier">completed</span>.<span class="ruby-identifier">empty?</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">completed</span>.<span class="ruby-identifier">send</span>(<span class="ruby-identifier">method</span>){<span class="ruby-operator">|</span><span class="ruby-identifier">promise</span><span class="ruby-operator">|</span> <span class="ruby-identifier">promise</span>.<span class="ruby-identifier">fulfilled?</span> }
      <span class="ruby-identifier">raise</span> <span class="ruby-constant">PromiseExecutionError</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-identifier">composite</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- aggregate-source -->
          
        </div>

        

        
      </div><!-- aggregate-method -->

    
    </section><!-- protected-class-method-details -->
  
     <section id="public-instance-5Buntitled-5D-method-details" class="method-section section">
      <h3 class="section-header">Public Instance Methods</h3>

    
      <div id="method-i-catch" class="method-detail method-alias">
        
        <div class="method-heading">
          <span class="method-name">catch</span><span
            class="method-args">(&block)</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
        </div>

        

        
        <div class="aliases">
          Alias for: <a href="Promise.html#method-i-rescue">rescue</a>
        </div>
        
      </div><!-- catch-method -->

    
      <div id="method-i-execute" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">execute</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Execute an `:unscheduled` `Promise`. Immediately sets the state to
`:pending` and passes the block to a new thread/thread pool for eventual
execution. Does nothing if the `Promise` is in any state other than
`:unscheduled`.</p>

<p>@return [Promise] a reference to `self`</p>
          
          

          
          <div class="method-source-code" id="execute-source">
            <pre><span class="ruby-comment"># File lib/concurrent/promise.rb, line 245</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">execute</span>
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">root?</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">compare_and_set_state</span>(<span class="ruby-value">:pending</span>, <span class="ruby-value">:unscheduled</span>)
      <span class="ruby-identifier">set_pending</span>
      <span class="ruby-identifier">realize</span>(<span class="ruby-ivar">@promise_body</span>)
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-ivar">@parent</span>.<span class="ruby-identifier">execute</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">self</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- execute-source -->
          
        </div>

        

        
      </div><!-- execute-method -->

    
      <div id="method-i-fail" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">fail</span><span
            class="method-args">(reason = StandardError.new)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>@!macro ivar_fail_method</p>

<p>@raise [Concurrent::PromiseExecutionError] if not the root promise</p>
          
          

          
          <div class="method-source-code" id="fail-source">
            <pre><span class="ruby-comment"># File lib/concurrent/promise.rb, line 276</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">fail</span>(<span class="ruby-identifier">reason</span> = <span class="ruby-constant">StandardError</span>.<span class="ruby-identifier">new</span>)
  <span class="ruby-identifier">set</span> { <span class="ruby-identifier">raise</span> <span class="ruby-identifier">reason</span> }
<span class="ruby-keyword">end</span></pre>
          </div><!-- fail-source -->
          
        </div>

        

        
      </div><!-- fail-method -->

    
      <div id="method-i-flat_map" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">flat_map</span><span
            class="method-args">(&block)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Yield the successful result to the block that returns a promise. If that
promise is also successful the result is the result of the yielded promise.
If either part fails the whole also fails.</p>

<p>@example</p>

<pre class="ruby"><span class="ruby-constant">Promise</span>.<span class="ruby-identifier">execute</span> { <span class="ruby-value">1</span> }.<span class="ruby-identifier">flat_map</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">v</span><span class="ruby-operator">|</span> <span class="ruby-constant">Promise</span>.<span class="ruby-identifier">execute</span> { <span class="ruby-identifier">v</span> <span class="ruby-operator">+</span> <span class="ruby-value">2</span> } }.<span class="ruby-identifier">value!</span> <span class="ruby-comment">#=&gt; 3</span>
</pre>

<p>@return [Promise]</p>
          
          

          
          <div class="method-source-code" id="flat_map-source">
            <pre><span class="ruby-comment"># File lib/concurrent/promise.rb, line 358</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">flat_map</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>)
  <span class="ruby-identifier">child</span> = <span class="ruby-constant">Promise</span>.<span class="ruby-identifier">new</span>(
    <span class="ruby-identifier">parent</span><span class="ruby-operator">:</span> <span class="ruby-keyword">self</span>,
    <span class="ruby-identifier">executor</span><span class="ruby-operator">:</span> <span class="ruby-constant">ImmediateExecutor</span>.<span class="ruby-identifier">new</span>,
  )

  <span class="ruby-identifier">on_error</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">e</span><span class="ruby-operator">|</span> <span class="ruby-identifier">child</span>.<span class="ruby-identifier">on_reject</span>(<span class="ruby-identifier">e</span>) }
  <span class="ruby-identifier">on_success</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">result1</span><span class="ruby-operator">|</span>
    <span class="ruby-keyword">begin</span>
      <span class="ruby-identifier">inner</span> = <span class="ruby-identifier">block</span>.<span class="ruby-identifier">call</span>(<span class="ruby-identifier">result1</span>)
      <span class="ruby-identifier">inner</span>.<span class="ruby-identifier">execute</span>
      <span class="ruby-identifier">inner</span>.<span class="ruby-identifier">on_success</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">result2</span><span class="ruby-operator">|</span> <span class="ruby-identifier">child</span>.<span class="ruby-identifier">on_fulfill</span>(<span class="ruby-identifier">result2</span>) }
      <span class="ruby-identifier">inner</span>.<span class="ruby-identifier">on_error</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">e</span><span class="ruby-operator">|</span> <span class="ruby-identifier">child</span>.<span class="ruby-identifier">on_reject</span>(<span class="ruby-identifier">e</span>) }
    <span class="ruby-keyword">rescue</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">e</span>
      <span class="ruby-identifier">child</span>.<span class="ruby-identifier">on_reject</span>(<span class="ruby-identifier">e</span>)
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">child</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- flat_map-source -->
          
        </div>

        

        
      </div><!-- flat_map-method -->

    
      <div id="method-i-on_error" class="method-detail method-alias">
        
        <div class="method-heading">
          <span class="method-name">on_error</span><span
            class="method-args">(&block)</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
        </div>

        

        
        <div class="aliases">
          Alias for: <a href="Promise.html#method-i-rescue">rescue</a>
        </div>
        
      </div><!-- on_error-method -->

    
      <div id="method-i-on_success" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">on_success</span><span
            class="method-args">(&block)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Chain onto this promise an action to be undertaken on success
(fulfillment).</p>

<p>@yield The block to execute</p>

<p>@return [Promise] self</p>
          
          

          
          <div class="method-source-code" id="on_success-source">
            <pre><span class="ruby-comment"># File lib/concurrent/promise.rb, line 332</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">on_success</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>)
  <span class="ruby-identifier">raise</span> <span class="ruby-constant">ArgumentError</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&#39;no block given&#39;</span>) <span class="ruby-keyword">unless</span> <span class="ruby-identifier">block_given?</span>
  <span class="ruby-keyword">self</span>.<span class="ruby-identifier">then</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>)
<span class="ruby-keyword">end</span></pre>
          </div><!-- on_success-source -->
          
        </div>

        

        
      </div><!-- on_success-method -->

    
      <div id="method-i-rescue" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">rescue</span><span
            class="method-args">(&block)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Chain onto this promise an action to be undertaken on failure (rejection).</p>

<p>@yield The block to execute</p>

<p>@return [Promise] self</p>
          
          

          
          <div class="method-source-code" id="rescue-source">
            <pre><span class="ruby-comment"># File lib/concurrent/promise.rb, line 343</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">rescue</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>)
  <span class="ruby-keyword">self</span>.<span class="ruby-identifier">then</span>(<span class="ruby-identifier">block</span>)
<span class="ruby-keyword">end</span></pre>
          </div><!-- rescue-source -->
          
        </div>

        
        <div class="aliases">
          Also aliased as: <a href="Promise.html#method-i-catch">catch</a>, <a href="Promise.html#method-i-on_error">on_error</a>
        </div>
        

        
      </div><!-- rescue-method -->

    
      <div id="method-i-set" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">set</span><span
            class="method-args">(value = NULL, &block)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>@!macro ivar_set_method</p>

<p>@raise [Concurrent::PromiseExecutionError] if not the root promise</p>
          
          

          
          <div class="method-source-code" id="set-source">
            <pre><span class="ruby-comment"># File lib/concurrent/promise.rb, line 260</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">set</span>(<span class="ruby-identifier">value</span> = <span class="ruby-constant">NULL</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>)
  <span class="ruby-identifier">raise</span> <span class="ruby-constant">PromiseExecutionError</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&#39;supported only on root promise&#39;</span>) <span class="ruby-keyword">unless</span> <span class="ruby-identifier">root?</span>
  <span class="ruby-identifier">check_for_block_or_value!</span>(<span class="ruby-identifier">block_given?</span>, <span class="ruby-identifier">value</span>)
  <span class="ruby-identifier">synchronize</span> <span class="ruby-keyword">do</span>
    <span class="ruby-keyword">if</span> <span class="ruby-ivar">@state</span> <span class="ruby-operator">!=</span> <span class="ruby-value">:unscheduled</span>
      <span class="ruby-identifier">raise</span> <span class="ruby-constant">MultipleAssignmentError</span>
    <span class="ruby-keyword">else</span>
      <span class="ruby-ivar">@promise_body</span> = <span class="ruby-identifier">block</span> <span class="ruby-operator">||</span> <span class="ruby-constant">Proc</span>.<span class="ruby-identifier">new</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">result</span><span class="ruby-operator">|</span> <span class="ruby-identifier">value</span> }
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-identifier">execute</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- set-source -->
          
        </div>

        

        
      </div><!-- set-method -->

    
      <div id="method-i-then" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">then</span><span
            class="method-args">(rescuer = nil, &block)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Chain a new promise off the current promise.</p>

<p>@param [Proc] rescuer An optional rescue block to be executed if the</p>

<pre>promise is rejected.</pre>

<p>@yield The block operation to be performed asynchronously.</p>

<p>@return [Promise] the new promise</p>
          
          

          
          <div class="method-source-code" id="then-source">
            <pre><span class="ruby-comment"># File lib/concurrent/promise.rb, line 306</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">then</span>(<span class="ruby-identifier">rescuer</span> = <span class="ruby-keyword">nil</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>)
  <span class="ruby-identifier">raise</span> <span class="ruby-constant">ArgumentError</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&#39;rescuers and block are both missing&#39;</span>) <span class="ruby-keyword">if</span> <span class="ruby-identifier">rescuer</span>.<span class="ruby-identifier">nil?</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-operator">!</span><span class="ruby-identifier">block_given?</span>
  <span class="ruby-identifier">block</span> = <span class="ruby-constant">Proc</span>.<span class="ruby-identifier">new</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">result</span><span class="ruby-operator">|</span> <span class="ruby-identifier">result</span> } <span class="ruby-keyword">unless</span> <span class="ruby-identifier">block_given?</span>
  <span class="ruby-identifier">child</span> = <span class="ruby-constant">Promise</span>.<span class="ruby-identifier">new</span>(
    <span class="ruby-identifier">parent</span><span class="ruby-operator">:</span> <span class="ruby-keyword">self</span>,
    <span class="ruby-identifier">executor</span><span class="ruby-operator">:</span> <span class="ruby-ivar">@executor</span>,
    <span class="ruby-identifier">on_fulfill</span><span class="ruby-operator">:</span> <span class="ruby-identifier">block</span>,
    <span class="ruby-identifier">on_reject</span><span class="ruby-operator">:</span> <span class="ruby-identifier">rescuer</span>
  )

  <span class="ruby-identifier">synchronize</span> <span class="ruby-keyword">do</span>
    <span class="ruby-identifier">child</span>.<span class="ruby-identifier">state</span> = <span class="ruby-value">:pending</span> <span class="ruby-keyword">if</span> <span class="ruby-ivar">@state</span> <span class="ruby-operator">==</span> <span class="ruby-value">:pending</span>
    <span class="ruby-identifier">child</span>.<span class="ruby-identifier">on_fulfill</span>(<span class="ruby-identifier">apply_deref_options</span>(<span class="ruby-ivar">@value</span>)) <span class="ruby-keyword">if</span> <span class="ruby-ivar">@state</span> <span class="ruby-operator">==</span> <span class="ruby-value">:fulfilled</span>
    <span class="ruby-identifier">child</span>.<span class="ruby-identifier">on_reject</span>(<span class="ruby-ivar">@reason</span>) <span class="ruby-keyword">if</span> <span class="ruby-ivar">@state</span> <span class="ruby-operator">==</span> <span class="ruby-value">:rejected</span>
    <span class="ruby-ivar">@children</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">child</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">child</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- then-source -->
          
        </div>

        

        
      </div><!-- then-method -->

    
      <div id="method-i-zip" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">zip</span><span
            class="method-args">(*others)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Builds a promise that produces the result of self and others in an <a
href="Array.html">Array</a> and fails if any of them fails.</p>

<p>@param [Array&lt;Promise&gt;] others</p>

<p>@return [Promise&lt;Array&gt;]</p>
          
          

          
          <div class="method-source-code" id="zip-source">
            <pre><span class="ruby-comment"># File lib/concurrent/promise.rb, line 403</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">zip</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">others</span>)
  <span class="ruby-keyword">self</span>.<span class="ruby-identifier">class</span>.<span class="ruby-identifier">zip</span>(<span class="ruby-keyword">self</span>, <span class="ruby-operator">*</span><span class="ruby-identifier">others</span>)
<span class="ruby-keyword">end</span></pre>
          </div><!-- zip-source -->
          
        </div>

        

        
      </div><!-- zip-method -->

    
    </section><!-- public-instance-method-details -->
  
     <section id="protected-instance-5Buntitled-5D-method-details" class="method-section section">
      <h3 class="section-header">Protected Instance Methods</h3>

    
      <div id="method-i-complete" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">complete</span><span
            class="method-args">(success, value, reason)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>@!visibility private</p>
          
          

          
          <div class="method-source-code" id="complete-source">
            <pre><span class="ruby-comment"># File lib/concurrent/promise.rb, line 514</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">complete</span>(<span class="ruby-identifier">success</span>, <span class="ruby-identifier">value</span>, <span class="ruby-identifier">reason</span>)
  <span class="ruby-identifier">children_to_notify</span> = <span class="ruby-identifier">synchronize</span> <span class="ruby-keyword">do</span>
    <span class="ruby-identifier">set_state!</span>(<span class="ruby-identifier">success</span>, <span class="ruby-identifier">value</span>, <span class="ruby-identifier">reason</span>)
    <span class="ruby-ivar">@children</span>.<span class="ruby-identifier">dup</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">children_to_notify</span>.<span class="ruby-identifier">each</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">child</span><span class="ruby-operator">|</span> <span class="ruby-identifier">notify_child</span>(<span class="ruby-identifier">child</span>) }
  <span class="ruby-identifier">observers</span>.<span class="ruby-identifier">notify_and_delete_observers</span>{ [<span class="ruby-constant">Time</span>.<span class="ruby-identifier">now</span>, <span class="ruby-keyword">self</span>.<span class="ruby-identifier">value</span>, <span class="ruby-identifier">reason</span>] }
<span class="ruby-keyword">end</span></pre>
          </div><!-- complete-source -->
          
        </div>

        

        
      </div><!-- complete-method -->

    
      <div id="method-i-notify_child" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">notify_child</span><span
            class="method-args">(child)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>@!visibility private</p>
          
          

          
          <div class="method-source-code" id="notify_child-source">
            <pre><span class="ruby-comment"># File lib/concurrent/promise.rb, line 508</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">notify_child</span>(<span class="ruby-identifier">child</span>)
  <span class="ruby-identifier">if_state</span>(<span class="ruby-value">:fulfilled</span>) { <span class="ruby-identifier">child</span>.<span class="ruby-identifier">on_fulfill</span>(<span class="ruby-identifier">apply_deref_options</span>(<span class="ruby-ivar">@value</span>)) }
  <span class="ruby-identifier">if_state</span>(<span class="ruby-value">:rejected</span>) { <span class="ruby-identifier">child</span>.<span class="ruby-identifier">on_reject</span>(<span class="ruby-ivar">@reason</span>) }
<span class="ruby-keyword">end</span></pre>
          </div><!-- notify_child-source -->
          
        </div>

        

        
      </div><!-- notify_child-method -->

    
      <div id="method-i-ns_initialize" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">ns_initialize</span><span
            class="method-args">(value, opts)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          
            <div class="method-calls-super">
              Calls superclass method
              <a href="IVar.html#method-i-ns_initialize">Concurrent::IVar#ns_initialize</a>
            </div>
          

          
          <div class="method-source-code" id="ns_initialize-source">
            <pre><span class="ruby-comment"># File lib/concurrent/promise.rb, line 444</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">ns_initialize</span>(<span class="ruby-identifier">value</span>, <span class="ruby-identifier">opts</span>)
  <span class="ruby-keyword">super</span>

  <span class="ruby-ivar">@executor</span> = <span class="ruby-constant">Options</span>.<span class="ruby-identifier">executor_from_options</span>(<span class="ruby-identifier">opts</span>) <span class="ruby-operator">||</span> <span class="ruby-constant">Concurrent</span>.<span class="ruby-identifier">global_io_executor</span>
  <span class="ruby-ivar">@args</span> = <span class="ruby-identifier">get_arguments_from</span>(<span class="ruby-identifier">opts</span>)

  <span class="ruby-ivar">@parent</span> = <span class="ruby-identifier">opts</span>.<span class="ruby-identifier">fetch</span>(<span class="ruby-value">:parent</span>) { <span class="ruby-keyword">nil</span> }
  <span class="ruby-ivar">@on_fulfill</span> = <span class="ruby-identifier">opts</span>.<span class="ruby-identifier">fetch</span>(<span class="ruby-value">:on_fulfill</span>) { <span class="ruby-constant">Proc</span>.<span class="ruby-identifier">new</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">result</span><span class="ruby-operator">|</span> <span class="ruby-identifier">result</span> } }
  <span class="ruby-ivar">@on_reject</span> = <span class="ruby-identifier">opts</span>.<span class="ruby-identifier">fetch</span>(<span class="ruby-value">:on_reject</span>) { <span class="ruby-constant">Proc</span>.<span class="ruby-identifier">new</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">reason</span><span class="ruby-operator">|</span> <span class="ruby-identifier">raise</span> <span class="ruby-identifier">reason</span> } }

  <span class="ruby-ivar">@promise_body</span> = <span class="ruby-identifier">opts</span>[<span class="ruby-value">:__promise_body_from_block__</span>] <span class="ruby-operator">||</span> <span class="ruby-constant">Proc</span>.<span class="ruby-identifier">new</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">result</span><span class="ruby-operator">|</span> <span class="ruby-identifier">result</span> }
  <span class="ruby-ivar">@state</span> = <span class="ruby-value">:unscheduled</span>
  <span class="ruby-ivar">@children</span> = []
<span class="ruby-keyword">end</span></pre>
          </div><!-- ns_initialize-source -->
          
        </div>

        

        
      </div><!-- ns_initialize-method -->

    
      <div id="method-i-on_fulfill" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">on_fulfill</span><span
            class="method-args">(result)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>@!visibility private</p>
          
          

          
          <div class="method-source-code" id="on_fulfill-source">
            <pre><span class="ruby-comment"># File lib/concurrent/promise.rb, line 496</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">on_fulfill</span>(<span class="ruby-identifier">result</span>)
  <span class="ruby-identifier">realize</span> <span class="ruby-constant">Proc</span>.<span class="ruby-identifier">new</span> { <span class="ruby-ivar">@on_fulfill</span>.<span class="ruby-identifier">call</span>(<span class="ruby-identifier">result</span>) }
  <span class="ruby-keyword">nil</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- on_fulfill-source -->
          
        </div>

        

        
      </div><!-- on_fulfill-method -->

    
      <div id="method-i-on_reject" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">on_reject</span><span
            class="method-args">(reason)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>@!visibility private</p>
          
          

          
          <div class="method-source-code" id="on_reject-source">
            <pre><span class="ruby-comment"># File lib/concurrent/promise.rb, line 502</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">on_reject</span>(<span class="ruby-identifier">reason</span>)
  <span class="ruby-identifier">realize</span> <span class="ruby-constant">Proc</span>.<span class="ruby-identifier">new</span> { <span class="ruby-ivar">@on_reject</span>.<span class="ruby-identifier">call</span>(<span class="ruby-identifier">reason</span>) }
  <span class="ruby-keyword">nil</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- on_reject-source -->
          
        </div>

        

        
      </div><!-- on_reject-method -->

    
      <div id="method-i-realize" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">realize</span><span
            class="method-args">(task)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>@!visibility private</p>
          
          

          
          <div class="method-source-code" id="realize-source">
            <pre><span class="ruby-comment"># File lib/concurrent/promise.rb, line 525</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">realize</span>(<span class="ruby-identifier">task</span>)
  <span class="ruby-ivar">@executor</span>.<span class="ruby-identifier">post</span> <span class="ruby-keyword">do</span>
    <span class="ruby-identifier">success</span>, <span class="ruby-identifier">value</span>, <span class="ruby-identifier">reason</span> = <span class="ruby-constant">SafeTaskExecutor</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">task</span>).<span class="ruby-identifier">execute</span>(<span class="ruby-operator">*</span><span class="ruby-ivar">@args</span>)
    <span class="ruby-identifier">complete</span>(<span class="ruby-identifier">success</span>, <span class="ruby-identifier">value</span>, <span class="ruby-identifier">reason</span>)
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- realize-source -->
          
        </div>

        

        
      </div><!-- realize-method -->

    
      <div id="method-i-set_pending" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">set_pending</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>@!visibility private</p>
          
          

          
          <div class="method-source-code" id="set_pending-source">
            <pre><span class="ruby-comment"># File lib/concurrent/promise.rb, line 483</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">set_pending</span>
  <span class="ruby-identifier">synchronize</span> <span class="ruby-keyword">do</span>
    <span class="ruby-ivar">@state</span> = <span class="ruby-value">:pending</span>
    <span class="ruby-ivar">@children</span>.<span class="ruby-identifier">each</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">c</span><span class="ruby-operator">|</span> <span class="ruby-identifier">c</span>.<span class="ruby-identifier">set_pending</span> }
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- set_pending-source -->
          
        </div>

        

        
      </div><!-- set_pending-method -->

    
      <div id="method-i-set_state-21" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">set_state!</span><span
            class="method-args">(success, value, reason)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>@!visibility private</p>
          
          

          
          <div class="method-source-code" id="set_state-21-source">
            <pre><span class="ruby-comment"># File lib/concurrent/promise.rb, line 533</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">set_state!</span>(<span class="ruby-identifier">success</span>, <span class="ruby-identifier">value</span>, <span class="ruby-identifier">reason</span>)
  <span class="ruby-identifier">set_state</span>(<span class="ruby-identifier">success</span>, <span class="ruby-identifier">value</span>, <span class="ruby-identifier">reason</span>)
  <span class="ruby-identifier">event</span>.<span class="ruby-identifier">set</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- set_state-21-source -->
          
        </div>

        

        
      </div><!-- set_state-21-method -->

    
      <div id="method-i-synchronized_set_state-21" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">synchronized_set_state!</span><span
            class="method-args">(success, value, reason)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>@!visibility private</p>
          
          

          
          <div class="method-source-code" id="synchronized_set_state-21-source">
            <pre><span class="ruby-comment"># File lib/concurrent/promise.rb, line 539</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">synchronized_set_state!</span>(<span class="ruby-identifier">success</span>, <span class="ruby-identifier">value</span>, <span class="ruby-identifier">reason</span>)
  <span class="ruby-identifier">synchronize</span> { <span class="ruby-identifier">set_state!</span>(<span class="ruby-identifier">success</span>, <span class="ruby-identifier">value</span>, <span class="ruby-identifier">reason</span>) }
<span class="ruby-keyword">end</span></pre>
          </div><!-- synchronized_set_state-21-source -->
          
        </div>

        

        
      </div><!-- synchronized_set_state-21-method -->

    
    </section><!-- protected-instance-method-details -->
  
  </section><!-- 5Buntitled-5D -->

</div><!-- documentation -->


<footer id="validator-badges">
  <p><a href="http://validator.w3.org/check/referer">[Validate]</a>
  <p>Generated by <a href="https://github.com/rdoc/rdoc">RDoc</a> 4.0.0.
  <p>Generated with the <a href="http://deveiate.org/projects/Darkfish-Rdoc/">Darkfish Rdoc Generator</a> 3.
</footer>

