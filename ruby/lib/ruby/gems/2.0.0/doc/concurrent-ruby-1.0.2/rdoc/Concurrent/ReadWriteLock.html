<!DOCTYPE html>

<html>
<head>
<meta content="text/html; charset=UTF-8" http-equiv="Content-Type">

<title>class Concurrent::ReadWriteLock - concurrent-ruby-1.0.2 Documentation</title>

<link type="text/css" media="screen" href="../rdoc.css" rel="stylesheet">

<script type="text/javascript">
  var rdoc_rel_prefix = "../";
</script>

<script type="text/javascript" charset="utf-8" src="../js/jquery.js"></script>
<script type="text/javascript" charset="utf-8" src="../js/navigation.js"></script>
<script type="text/javascript" charset="utf-8" src="../js/search_index.js"></script>
<script type="text/javascript" charset="utf-8" src="../js/search.js"></script>
<script type="text/javascript" charset="utf-8" src="../js/searcher.js"></script>
<script type="text/javascript" charset="utf-8" src="../js/darkfish.js"></script>


<body id="top" class="class">
<nav id="metadata">
  <nav id="home-section" class="section">
  <h3 class="section-header">
    <a href="../index.html">Home</a>
    <a href="../table_of_contents.html#classes">Classes</a>
    <a href="../table_of_contents.html#methods">Methods</a>
  </h3>
</nav>


  <nav id="search-section" class="section project-section" class="initially-hidden">
  <form action="#" method="get" accept-charset="utf-8">
    <h3 class="section-header">
      <input type="text" name="search" placeholder="Search" id="search-field"
             title="Type to search, Up and Down to navigate, Enter to load">
    </h3>
  </form>

  <ul id="search-results" class="initially-hidden"></ul>
</nav>


  

  <div id="file-metadata">
    <nav id="file-list-section" class="section">
  <h3 class="section-header">Defined In</h3>
  <ul>
    <li>lib/concurrent/atomic/read_write_lock.rb
  </ul>
</nav>

    
  </div>

  <div id="class-metadata">
    
    <nav id="parent-class-section" class="section">
  <h3 class="section-header">Parent</h3>
  
  <p class="link">Synchronization::Object
  
</nav>

    
    
    <!-- Method Quickref -->
<nav id="method-list-section" class="section">
  <h3 class="section-header">Methods</h3>

  <ul class="link-list">
    
    <li class="calls-super" ><a href="#method-c-new">::new</a>
    
    <li ><a href="#method-i-acquire_read_lock">#acquire_read_lock</a>
    
    <li ><a href="#method-i-acquire_write_lock">#acquire_write_lock</a>
    
    <li ><a href="#method-i-has_waiters-3F">#has_waiters?</a>
    
    <li ><a href="#method-i-max_readers-3F">#max_readers?</a>
    
    <li ><a href="#method-i-max_writers-3F">#max_writers?</a>
    
    <li ><a href="#method-i-release_read_lock">#release_read_lock</a>
    
    <li ><a href="#method-i-release_write_lock">#release_write_lock</a>
    
    <li ><a href="#method-i-running_readers">#running_readers</a>
    
    <li ><a href="#method-i-running_readers-3F">#running_readers?</a>
    
    <li ><a href="#method-i-running_writer-3F">#running_writer?</a>
    
    <li ><a href="#method-i-waiting_writer-3F">#waiting_writer?</a>
    
    <li ><a href="#method-i-waiting_writers">#waiting_writers</a>
    
    <li ><a href="#method-i-with_read_lock">#with_read_lock</a>
    
    <li ><a href="#method-i-with_write_lock">#with_write_lock</a>
    
    <li ><a href="#method-i-write_locked-3F">#write_locked?</a>
    
  </ul>
</nav>

  </div>

  <div id="project-metadata">
    <nav id="fileindex-section" class="section project-section">
  <h3 class="section-header">Pages</h3>

  <ul>
  
    <li class="file"><a href="../CHANGELOG_md.html">CHANGELOG</a>
  
    <li class="file"><a href="../LICENSE_txt.html">LICENSE</a>
  
    <li class="file"><a href="../README_md.html">README</a>
  
  </ul>
</nav>

    <nav id="classindex-section" class="section project-section">
  <h3 class="section-header">Class and Module Index</h3>

  <ul class="link-list">
  
    <li><a href="../Concurrent.html">Concurrent</a>
  
    <li><a href="../Concurrent/AbstractExchanger.html">Concurrent::AbstractExchanger</a>
  
    <li><a href="../Concurrent/AbstractExecutorService.html">Concurrent::AbstractExecutorService</a>
  
    <li><a href="../Concurrent/AbstractThreadLocalVar.html">Concurrent::AbstractThreadLocalVar</a>
  
    <li><a href="../Concurrent/Agent.html">Concurrent::Agent</a>
  
    <li><a href="../Concurrent/Agent/Error.html">Concurrent::Agent::Error</a>
  
    <li><a href="../Concurrent/Agent/ValidationError.html">Concurrent::Agent::ValidationError</a>
  
    <li><a href="../Concurrent/Array.html">Concurrent::Array</a>
  
    <li><a href="../Concurrent/Async.html">Concurrent::Async</a>
  
    <li><a href="../Concurrent/Async/AsyncDelegator.html">Concurrent::Async::AsyncDelegator</a>
  
    <li><a href="../Concurrent/Async/AwaitDelegator.html">Concurrent::Async::AwaitDelegator</a>
  
    <li><a href="../Concurrent/Async/ClassMethods.html">Concurrent::Async::ClassMethods</a>
  
    <li><a href="../Concurrent/AtExitImplementation.html">Concurrent::AtExitImplementation</a>
  
    <li><a href="../Concurrent/Atom.html">Concurrent::Atom</a>
  
    <li><a href="../Concurrent/AtomicBoolean.html">Concurrent::AtomicBoolean</a>
  
    <li><a href="../Concurrent/AtomicDirectUpdate.html">Concurrent::AtomicDirectUpdate</a>
  
    <li><a href="../Concurrent/AtomicFixnum.html">Concurrent::AtomicFixnum</a>
  
    <li><a href="../Concurrent/AtomicNumericCompareAndSetWrapper.html">Concurrent::AtomicNumericCompareAndSetWrapper</a>
  
    <li><a href="../Concurrent/AtomicReference.html">Concurrent::AtomicReference</a>
  
    <li><a href="../Concurrent/CAtomicReference.html">Concurrent::CAtomicReference</a>
  
    <li><a href="../Concurrent/CachedThreadPool.html">Concurrent::CachedThreadPool</a>
  
    <li><a href="../Concurrent/Collection.html">Concurrent::Collection</a>
  
    <li><a href="../Concurrent/Collection/AtomicReferenceMapBackend.html">Concurrent::Collection::AtomicReferenceMapBackend</a>
  
    <li><a href="../Concurrent/Collection/AtomicReferenceMapBackend/Node.html">Concurrent::Collection::AtomicReferenceMapBackend::Node</a>
  
    <li><a href="../Concurrent/Collection/AtomicReferenceMapBackend/Table.html">Concurrent::Collection::AtomicReferenceMapBackend::Table</a>
  
    <li><a href="../Concurrent/Collection/CopyOnNotifyObserverSet.html">Concurrent::Collection::CopyOnNotifyObserverSet</a>
  
    <li><a href="../Concurrent/Collection/CopyOnWriteObserverSet.html">Concurrent::Collection::CopyOnWriteObserverSet</a>
  
    <li><a href="../Concurrent/Collection/JavaNonConcurrentPriorityQueue.html">Concurrent::Collection::JavaNonConcurrentPriorityQueue</a>
  
    <li><a href="../Concurrent/Collection/MriMapBackend.html">Concurrent::Collection::MriMapBackend</a>
  
    <li><a href="../Concurrent/Collection/NonConcurrentMapBackend.html">Concurrent::Collection::NonConcurrentMapBackend</a>
  
    <li><a href="../Concurrent/Collection/NonConcurrentPriorityQueue.html">Concurrent::Collection::NonConcurrentPriorityQueue</a>
  
    <li><a href="../Concurrent/Collection/RubyNonConcurrentPriorityQueue.html">Concurrent::Collection::RubyNonConcurrentPriorityQueue</a>
  
    <li><a href="../Concurrent/Collection/SynchronizedMapBackend.html">Concurrent::Collection::SynchronizedMapBackend</a>
  
    <li><a href="../Concurrent/Concern.html">Concurrent::Concern</a>
  
    <li><a href="../Concurrent/Concern/Deprecation.html">Concurrent::Concern::Deprecation</a>
  
    <li><a href="../Concurrent/Concern/Dereferenceable.html">Concurrent::Concern::Dereferenceable</a>
  
    <li><a href="../Concurrent/Concern/Logging.html">Concurrent::Concern::Logging</a>
  
    <li><a href="../Concurrent/Concern/Obligation.html">Concurrent::Concern::Obligation</a>
  
    <li><a href="../Concurrent/Concern/Observable.html">Concurrent::Concern::Observable</a>
  
    <li><a href="../Concurrent/ConcurrentUpdateError.html">Concurrent::ConcurrentUpdateError</a>
  
    <li><a href="../Concurrent/CountDownLatch.html">Concurrent::CountDownLatch</a>
  
    <li><a href="../Concurrent/CyclicBarrier.html">Concurrent::CyclicBarrier</a>
  
    <li><a href="../Concurrent/Delay.html">Concurrent::Delay</a>
  
    <li><a href="../Concurrent/DependencyCounter.html">Concurrent::DependencyCounter</a>
  
    <li><a href="../Concurrent/Edge.html">Concurrent::Edge</a>
  
    <li><a href="../Concurrent/Event.html">Concurrent::Event</a>
  
    <li><a href="../Concurrent/Exchanger.html">Concurrent::Exchanger</a>
  
    <li><a href="../Concurrent/ExecutorService.html">Concurrent::ExecutorService</a>
  
    <li><a href="../Concurrent/FixedThreadPool.html">Concurrent::FixedThreadPool</a>
  
    <li><a href="../Concurrent/Future.html">Concurrent::Future</a>
  
    <li><a href="../Concurrent/Hash.html">Concurrent::Hash</a>
  
    <li><a href="../Concurrent/IVar.html">Concurrent::IVar</a>
  
    <li><a href="../Concurrent/ImmediateExecutor.html">Concurrent::ImmediateExecutor</a>
  
    <li><a href="../Concurrent/ImmutableStruct.html">Concurrent::ImmutableStruct</a>
  
    <li><a href="../Concurrent/IndirectImmediateExecutor.html">Concurrent::IndirectImmediateExecutor</a>
  
    <li><a href="../Concurrent/JavaAtomicReference.html">Concurrent::JavaAtomicReference</a>
  
    <li><a href="../Concurrent/JavaCountDownLatch.html">Concurrent::JavaCountDownLatch</a>
  
    <li><a href="../Concurrent/JavaExchanger.html">Concurrent::JavaExchanger</a>
  
    <li><a href="../Concurrent/JavaExecutorService.html">Concurrent::JavaExecutorService</a>
  
    <li><a href="../Concurrent/JavaExecutorService/Job.html">Concurrent::JavaExecutorService::Job</a>
  
    <li><a href="../Concurrent/JavaSingleThreadExecutor.html">Concurrent::JavaSingleThreadExecutor</a>
  
    <li><a href="../Concurrent/JavaThreadLocalVar.html">Concurrent::JavaThreadLocalVar</a>
  
    <li><a href="../Concurrent/JavaThreadPoolExecutor.html">Concurrent::JavaThreadPoolExecutor</a>
  
    <li><a href="../Concurrent/LazyRegister.html">Concurrent::LazyRegister</a>
  
    <li><a href="../Concurrent/MVar.html">Concurrent::MVar</a>
  
    <li><a href="../Concurrent/Map.html">Concurrent::Map</a>
  
    <li><a href="../Concurrent/Maybe.html">Concurrent::Maybe</a>
  
    <li><a href="../Concurrent/MutableStruct.html">Concurrent::MutableStruct</a>
  
    <li><a href="../Concurrent/MutexAtomicBoolean.html">Concurrent::MutexAtomicBoolean</a>
  
    <li><a href="../Concurrent/MutexAtomicFixnum.html">Concurrent::MutexAtomicFixnum</a>
  
    <li><a href="../Concurrent/MutexAtomicReference.html">Concurrent::MutexAtomicReference</a>
  
    <li><a href="../Concurrent/MutexCountDownLatch.html">Concurrent::MutexCountDownLatch</a>
  
    <li><a href="../Concurrent/MutexSemaphore.html">Concurrent::MutexSemaphore</a>
  
    <li><a href="../Concurrent/Options.html">Concurrent::Options</a>
  
    <li><a href="../Concurrent/Process.html">Concurrent::Process</a>
  
    <li><a href="../Concurrent/Promise.html">Concurrent::Promise</a>
  
    <li><a href="../Concurrent/RbxAtomicReference.html">Concurrent::RbxAtomicReference</a>
  
    <li><a href="../Concurrent/ReadWriteLock.html">Concurrent::ReadWriteLock</a>
  
    <li><a href="../Concurrent/ReentrantReadWriteLock.html">Concurrent::ReentrantReadWriteLock</a>
  
    <li><a href="../Concurrent/RubyExchanger.html">Concurrent::RubyExchanger</a>
  
    <li><a href="../Concurrent/RubyExchanger/Node.html">Concurrent::RubyExchanger::Node</a>
  
    <li><a href="../Concurrent/RubyExecutorService.html">Concurrent::RubyExecutorService</a>
  
    <li><a href="../Concurrent/RubySingleThreadExecutor.html">Concurrent::RubySingleThreadExecutor</a>
  
    <li><a href="../Concurrent/RubyThreadLocalVar.html">Concurrent::RubyThreadLocalVar</a>
  
    <li><a href="../Concurrent/RubyThreadPoolExecutor.html">Concurrent::RubyThreadPoolExecutor</a>
  
    <li><a href="../Concurrent/RubyThreadPoolExecutor/Worker.html">Concurrent::RubyThreadPoolExecutor::Worker</a>
  
    <li><a href="../Concurrent/SafeTaskExecutor.html">Concurrent::SafeTaskExecutor</a>
  
    <li><a href="../Concurrent/ScheduledTask.html">Concurrent::ScheduledTask</a>
  
    <li><a href="../Concurrent/Semaphore.html">Concurrent::Semaphore</a>
  
    <li><a href="../Concurrent/SerialExecutorService.html">Concurrent::SerialExecutorService</a>
  
    <li><a href="../Concurrent/SerializedExecution.html">Concurrent::SerializedExecution</a>
  
    <li><a href="../Concurrent/SerializedExecutionDelegator.html">Concurrent::SerializedExecutionDelegator</a>
  
    <li><a href="../Concurrent/SettableStruct.html">Concurrent::SettableStruct</a>
  
    <li><a href="../Concurrent/SimpleExecutorService.html">Concurrent::SimpleExecutorService</a>
  
    <li><a href="../Concurrent/SingleThreadExecutor.html">Concurrent::SingleThreadExecutor</a>
  
    <li><a href="../Concurrent/Synchronization.html">Concurrent::Synchronization</a>
  
    <li><a href="../Concurrent/Synchronization/AbstractLockableObject.html">Concurrent::Synchronization::AbstractLockableObject</a>
  
    <li><a href="../Concurrent/Synchronization/AbstractObject.html">Concurrent::Synchronization::AbstractObject</a>
  
    <li><a href="../Concurrent/Synchronization/AbstractStruct.html">Concurrent::Synchronization::AbstractStruct</a>
  
    <li><a href="../Concurrent/Synchronization/Condition.html">Concurrent::Synchronization::Condition</a>
  
    <li><a href="../Concurrent/Synchronization/JRubyAttrVolatile.html">Concurrent::Synchronization::JRubyAttrVolatile</a>
  
    <li><a href="../Concurrent/Synchronization/JRubyAttrVolatile/ClassMethods.html">Concurrent::Synchronization::JRubyAttrVolatile::ClassMethods</a>
  
    <li><a href="../Concurrent/Synchronization/JRubyLockableObject.html">Concurrent::Synchronization::JRubyLockableObject</a>
  
    <li><a href="../Concurrent/Synchronization/JRubyObject.html">Concurrent::Synchronization::JRubyObject</a>
  
    <li><a href="../Concurrent/Synchronization/Lock.html">Concurrent::Synchronization::Lock</a>
  
    <li><a href="../Concurrent/Synchronization/LockableObject.html">Concurrent::Synchronization::LockableObject</a>
  
    <li><a href="../Concurrent/Synchronization/MriAttrVolatile.html">Concurrent::Synchronization::MriAttrVolatile</a>
  
    <li><a href="../Concurrent/Synchronization/MriAttrVolatile/ClassMethods.html">Concurrent::Synchronization::MriAttrVolatile::ClassMethods</a>
  
    <li><a href="../Concurrent/Synchronization/MriLockableObject.html">Concurrent::Synchronization::MriLockableObject</a>
  
    <li><a href="../Concurrent/Synchronization/MriMonitorLockableObject.html">Concurrent::Synchronization::MriMonitorLockableObject</a>
  
    <li><a href="../Concurrent/Synchronization/MriMutexLockableObject.html">Concurrent::Synchronization::MriMutexLockableObject</a>
  
    <li><a href="../Concurrent/Synchronization/MriObject.html">Concurrent::Synchronization::MriObject</a>
  
    <li><a href="../Concurrent/Synchronization/Object.html">Concurrent::Synchronization::Object</a>
  
    <li><a href="../Concurrent/Synchronization/RbxAttrVolatile.html">Concurrent::Synchronization::RbxAttrVolatile</a>
  
    <li><a href="../Concurrent/Synchronization/RbxAttrVolatile/ClassMethods.html">Concurrent::Synchronization::RbxAttrVolatile::ClassMethods</a>
  
    <li><a href="../Concurrent/Synchronization/RbxLockableObject.html">Concurrent::Synchronization::RbxLockableObject</a>
  
    <li><a href="../Concurrent/Synchronization/RbxObject.html">Concurrent::Synchronization::RbxObject</a>
  
    <li><a href="../Concurrent/Synchronization/TruffleAttrVolatile.html">Concurrent::Synchronization::TruffleAttrVolatile</a>
  
    <li><a href="../Concurrent/Synchronization/TruffleAttrVolatile/ClassMethods.html">Concurrent::Synchronization::TruffleAttrVolatile::ClassMethods</a>
  
    <li><a href="../Concurrent/Synchronization/TruffleLockableObject.html">Concurrent::Synchronization::TruffleLockableObject</a>
  
    <li><a href="../Concurrent/Synchronization/TruffleObject.html">Concurrent::Synchronization::TruffleObject</a>
  
    <li><a href="../Concurrent/SynchronizedDelegator.html">Concurrent::SynchronizedDelegator</a>
  
    <li><a href="../Concurrent/TVar.html">Concurrent::TVar</a>
  
    <li><a href="../Concurrent/ThreadLocalVar.html">Concurrent::ThreadLocalVar</a>
  
    <li><a href="../Concurrent/ThreadPoolExecutor.html">Concurrent::ThreadPoolExecutor</a>
  
    <li><a href="../Concurrent/ThreadSafe.html">Concurrent::ThreadSafe</a>
  
    <li><a href="../Concurrent/ThreadSafe/Util.html">Concurrent::ThreadSafe::Util</a>
  
    <li><a href="../Concurrent/ThreadSafe/Util/Adder.html">Concurrent::ThreadSafe::Util::Adder</a>
  
    <li><a href="../Concurrent/ThreadSafe/Util/CheapLockable.html">Concurrent::ThreadSafe::Util::CheapLockable</a>
  
    <li><a href="../Concurrent/ThreadSafe/Util/PowerOfTwoTuple.html">Concurrent::ThreadSafe::Util::PowerOfTwoTuple</a>
  
    <li><a href="../Concurrent/ThreadSafe/Util/Striped64.html">Concurrent::ThreadSafe::Util::Striped64</a>
  
    <li><a href="../Concurrent/ThreadSafe/Util/Striped64/Cell.html">Concurrent::ThreadSafe::Util::Striped64::Cell</a>
  
    <li><a href="../Concurrent/ThreadSafe/Util/Volatile.html">Concurrent::ThreadSafe::Util::Volatile</a>
  
    <li><a href="../Concurrent/ThreadSafe/Util/XorShiftRandom.html">Concurrent::ThreadSafe::Util::XorShiftRandom</a>
  
    <li><a href="../Concurrent/TimerSet.html">Concurrent::TimerSet</a>
  
    <li><a href="../Concurrent/TimerTask.html">Concurrent::TimerTask</a>
  
    <li><a href="../Concurrent/Transaction.html">Concurrent::Transaction</a>
  
    <li><a href="../Concurrent/Tuple.html">Concurrent::Tuple</a>
  
    <li><a href="../Concurrent/Utility.html">Concurrent::Utility</a>
  
    <li><a href="../Concurrent/Utility/EngineDetector.html">Concurrent::Utility::EngineDetector</a>
  
    <li><a href="../Concurrent/Utility/NativeExtensionLoader.html">Concurrent::Utility::NativeExtensionLoader</a>
  
    <li><a href="../Concurrent/Utility/ProcessorCounter.html">Concurrent::Utility::ProcessorCounter</a>
  
  </ul>
</nav>

  </div>
</nav>

<div id="documentation">
  <h1 class="class">class Concurrent::ReadWriteLock</h1>

  <div id="description" class="description">
    
<p>Ruby read-write lock implementation</p>

<p>Allows any number of concurrent readers, but only one concurrent writer
(And if the “write” lock is taken, any readers who come along will have to
wait)</p>

<p>If readers are already active when a writer comes along, the writer will
wait for all the readers to finish before going ahead. Any additional
readers that come when the writer is already waiting, will also wait (so
writers are not starved).</p>

<p>This implementation is based on
`java.util.concurrent.ReentrantReadWriteLock`.</p>

<p>@example</p>

<pre>lock = Concurrent::ReadWriteLock.new
lock.with_read_lock  { data.retrieve }
lock.with_write_lock { data.modify! }</pre>

<p>@note Do *<strong>not</strong>* try to acquire the write lock while already
holding a read lock</p>

<pre>**or** try to acquire the write lock while you already have it.
This will lead to deadlock</pre>

<p>@see <a
href="http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/locks/ReentrantReadWriteLock.html">docs.oracle.com/javase/7/docs/api/java/util/concurrent/locks/ReentrantReadWriteLock.html</a>
java.util.concurrent.ReentrantReadWriteLock</p>

  </div><!-- description -->

  
  
  
  <section id="5Buntitled-5D" class="documentation-section">
    

    

    
    <!-- Constants -->
    <section id="constants-list" class="section">
      <h3 class="section-header">Constants</h3>
      <dl>
      
        <dt id="MAX_READERS">MAX_READERS
        
        <dd class="description"><p>@!visibility private</p>
        
      
        <dt id="MAX_WRITERS">MAX_WRITERS
        
        <dd class="description"><p>@!visibility private</p>
        
      
        <dt id="RUNNING_WRITER">RUNNING_WRITER
        
        <dd class="description"><p>@!visibility private</p>
        
      
        <dt id="WAITING_WRITER">WAITING_WRITER
        
        <dd class="description"><p>@!visibility private</p>
        
      
      </dl>
    </section>
    

    

    <!-- Methods -->
    
     <section id="public-class-5Buntitled-5D-method-details" class="method-section section">
      <h3 class="section-header">Public Class Methods</h3>

    
      <div id="method-c-new" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">new</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Create a new `ReadWriteLock` in the unlocked state.</p>
          
          
            <div class="method-calls-super">
              Calls superclass method
              
            </div>
          

          
          <div class="method-source-code" id="new-source">
            <pre><span class="ruby-comment"># File lib/concurrent/atomic/read_write_lock.rb, line 58</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">initialize</span>
  <span class="ruby-keyword">super</span>()
  <span class="ruby-ivar">@Counter</span>   = <span class="ruby-constant">AtomicFixnum</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">0</span>) <span class="ruby-comment"># single integer which represents lock state</span>
  <span class="ruby-ivar">@ReadLock</span>  = <span class="ruby-constant">Synchronization</span><span class="ruby-operator">::</span><span class="ruby-constant">Lock</span>.<span class="ruby-identifier">new</span>
  <span class="ruby-ivar">@WriteLock</span> = <span class="ruby-constant">Synchronization</span><span class="ruby-operator">::</span><span class="ruby-constant">Lock</span>.<span class="ruby-identifier">new</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- new-source -->
          
        </div>

        

        
      </div><!-- new-method -->

    
    </section><!-- public-class-method-details -->
  
     <section id="public-instance-5Buntitled-5D-method-details" class="method-section section">
      <h3 class="section-header">Public Instance Methods</h3>

    
      <div id="method-i-acquire_read_lock" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">acquire_read_lock</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Acquire a read lock. If a write lock has been acquired will block until it
is released. Will not block if other read locks have been acquired.</p>

<p>@return [Boolean] true if the lock is successfully acquired</p>

<p>@raise [Concurrent::ResourceLimitError] if the maximum number of readers</p>

<pre>is exceeded.</pre>
          
          

          
          <div class="method-source-code" id="acquire_read_lock-source">
            <pre><span class="ruby-comment"># File lib/concurrent/atomic/read_write_lock.rb, line 110</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">acquire_read_lock</span>
  <span class="ruby-keyword">while</span> <span class="ruby-keyword">true</span>
    <span class="ruby-identifier">c</span> = <span class="ruby-ivar">@Counter</span>.<span class="ruby-identifier">value</span>
    <span class="ruby-identifier">raise</span> <span class="ruby-constant">ResourceLimitError</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&#39;Too many reader threads&#39;</span>) <span class="ruby-keyword">if</span> <span class="ruby-identifier">max_readers?</span>(<span class="ruby-identifier">c</span>)

    <span class="ruby-comment"># If a writer is waiting when we first queue up, we need to wait</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">waiting_writer?</span>(<span class="ruby-identifier">c</span>)
      <span class="ruby-ivar">@ReadLock</span>.<span class="ruby-identifier">wait_until</span> { <span class="ruby-operator">!</span><span class="ruby-identifier">waiting_writer?</span> }

      <span class="ruby-comment"># after a reader has waited once, they are allowed to &quot;barge&quot; ahead of waiting writers</span>
      <span class="ruby-comment"># but if a writer is *running*, the reader still needs to wait (naturally)</span>
      <span class="ruby-keyword">while</span> <span class="ruby-keyword">true</span>
        <span class="ruby-identifier">c</span> = <span class="ruby-ivar">@Counter</span>.<span class="ruby-identifier">value</span>
        <span class="ruby-keyword">if</span> <span class="ruby-identifier">running_writer?</span>(<span class="ruby-identifier">c</span>)
          <span class="ruby-ivar">@ReadLock</span>.<span class="ruby-identifier">wait_until</span> { <span class="ruby-operator">!</span><span class="ruby-identifier">running_writer?</span> }
        <span class="ruby-keyword">else</span>
          <span class="ruby-keyword">return</span> <span class="ruby-keyword">if</span> <span class="ruby-ivar">@Counter</span>.<span class="ruby-identifier">compare_and_set</span>(<span class="ruby-identifier">c</span>, <span class="ruby-identifier">c</span><span class="ruby-operator">+</span><span class="ruby-value">1</span>)
        <span class="ruby-keyword">end</span>
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">else</span>
      <span class="ruby-keyword">break</span> <span class="ruby-keyword">if</span> <span class="ruby-ivar">@Counter</span>.<span class="ruby-identifier">compare_and_set</span>(<span class="ruby-identifier">c</span>, <span class="ruby-identifier">c</span><span class="ruby-operator">+</span><span class="ruby-value">1</span>)
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">true</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- acquire_read_lock-source -->
          
        </div>

        

        
      </div><!-- acquire_read_lock-method -->

    
      <div id="method-i-acquire_write_lock" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">acquire_write_lock</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Acquire a write lock. Will block and wait for all active readers and
writers.</p>

<p>@return [Boolean] true if the lock is successfully acquired</p>

<p>@raise [Concurrent::ResourceLimitError] if the maximum number of writers</p>

<pre>is exceeded.</pre>
          
          

          
          <div class="method-source-code" id="acquire_write_lock-source">
            <pre><span class="ruby-comment"># File lib/concurrent/atomic/read_write_lock.rb, line 159</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">acquire_write_lock</span>
  <span class="ruby-keyword">while</span> <span class="ruby-keyword">true</span>
    <span class="ruby-identifier">c</span> = <span class="ruby-ivar">@Counter</span>.<span class="ruby-identifier">value</span>
    <span class="ruby-identifier">raise</span> <span class="ruby-constant">ResourceLimitError</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&#39;Too many writer threads&#39;</span>) <span class="ruby-keyword">if</span> <span class="ruby-identifier">max_writers?</span>(<span class="ruby-identifier">c</span>)

    <span class="ruby-keyword">if</span> <span class="ruby-identifier">c</span> <span class="ruby-operator">==</span> <span class="ruby-value">0</span> <span class="ruby-comment"># no readers OR writers running</span>
      <span class="ruby-comment"># if we successfully swap the RUNNING_WRITER bit on, then we can go ahead</span>
      <span class="ruby-keyword">break</span> <span class="ruby-keyword">if</span> <span class="ruby-ivar">@Counter</span>.<span class="ruby-identifier">compare_and_set</span>(<span class="ruby-value">0</span>, <span class="ruby-constant">RUNNING_WRITER</span>)
    <span class="ruby-keyword">elsif</span> <span class="ruby-ivar">@Counter</span>.<span class="ruby-identifier">compare_and_set</span>(<span class="ruby-identifier">c</span>, <span class="ruby-identifier">c</span><span class="ruby-operator">+</span><span class="ruby-constant">WAITING_WRITER</span>)
      <span class="ruby-keyword">while</span> <span class="ruby-keyword">true</span>
        <span class="ruby-comment"># Now we have successfully incremented, so no more readers will be able to increment</span>
        <span class="ruby-comment">#   (they will wait instead)</span>
        <span class="ruby-comment"># However, readers OR writers could decrement right here, OR another writer could increment</span>
        <span class="ruby-ivar">@WriteLock</span>.<span class="ruby-identifier">wait_until</span> <span class="ruby-keyword">do</span>
          <span class="ruby-comment"># So we have to do another check inside the synchronized section</span>
          <span class="ruby-comment"># If a writer OR reader is running, then go to sleep</span>
          <span class="ruby-identifier">c</span> = <span class="ruby-ivar">@Counter</span>.<span class="ruby-identifier">value</span>
          <span class="ruby-operator">!</span><span class="ruby-identifier">running_writer?</span>(<span class="ruby-identifier">c</span>) <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-operator">!</span><span class="ruby-identifier">running_readers?</span>(<span class="ruby-identifier">c</span>)
        <span class="ruby-keyword">end</span>

        <span class="ruby-comment"># We just came out of a wait</span>
        <span class="ruby-comment"># If we successfully turn the RUNNING_WRITER bit on with an atomic swap,</span>
        <span class="ruby-comment"># Then we are OK to stop waiting and go ahead</span>
        <span class="ruby-comment"># Otherwise go back and wait again</span>
        <span class="ruby-identifier">c</span> = <span class="ruby-ivar">@Counter</span>.<span class="ruby-identifier">value</span>
        <span class="ruby-keyword">break</span> <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">running_writer?</span>(<span class="ruby-identifier">c</span>) <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-operator">!</span><span class="ruby-identifier">running_readers?</span>(<span class="ruby-identifier">c</span>) <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-ivar">@Counter</span>.<span class="ruby-identifier">compare_and_set</span>(<span class="ruby-identifier">c</span>, <span class="ruby-identifier">c</span><span class="ruby-operator">+</span><span class="ruby-constant">RUNNING_WRITER</span><span class="ruby-operator">-</span><span class="ruby-constant">WAITING_WRITER</span>)
      <span class="ruby-keyword">end</span>
      <span class="ruby-keyword">break</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">true</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- acquire_write_lock-source -->
          
        </div>

        

        
      </div><!-- acquire_write_lock-method -->

    
      <div id="method-i-has_waiters-3F" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">has_waiters?</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Queries whether any threads are waiting to acquire the read or write lock.</p>

<p>@return [Boolean] true if any threads are waiting for a lock else false</p>
          
          

          
          <div class="method-source-code" id="has_waiters-3F-source">
            <pre><span class="ruby-comment"># File lib/concurrent/atomic/read_write_lock.rb, line 212</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">has_waiters?</span>
  <span class="ruby-identifier">waiting_writer?</span>(<span class="ruby-ivar">@Counter</span>.<span class="ruby-identifier">value</span>)
<span class="ruby-keyword">end</span></pre>
          </div><!-- has_waiters-3F-source -->
          
        </div>

        

        
      </div><!-- has_waiters-3F-method -->

    
      <div id="method-i-release_read_lock" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">release_read_lock</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Release a previously acquired read lock.</p>

<p>@return [Boolean] true if the lock is successfully released</p>
          
          

          
          <div class="method-source-code" id="release_read_lock-source">
            <pre><span class="ruby-comment"># File lib/concurrent/atomic/read_write_lock.rb, line 139</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">release_read_lock</span>
  <span class="ruby-keyword">while</span> <span class="ruby-keyword">true</span>
    <span class="ruby-identifier">c</span> = <span class="ruby-ivar">@Counter</span>.<span class="ruby-identifier">value</span>
    <span class="ruby-keyword">if</span> <span class="ruby-ivar">@Counter</span>.<span class="ruby-identifier">compare_and_set</span>(<span class="ruby-identifier">c</span>, <span class="ruby-identifier">c</span><span class="ruby-operator">-</span><span class="ruby-value">1</span>)
      <span class="ruby-comment"># If one or more writers were waiting, and we were the last reader, wake a writer up</span>
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">waiting_writer?</span>(<span class="ruby-identifier">c</span>) <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">running_readers</span>(<span class="ruby-identifier">c</span>) <span class="ruby-operator">==</span> <span class="ruby-value">1</span>
        <span class="ruby-ivar">@WriteLock</span>.<span class="ruby-identifier">signal</span>
      <span class="ruby-keyword">end</span>
      <span class="ruby-keyword">break</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">true</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- release_read_lock-source -->
          
        </div>

        

        
      </div><!-- release_read_lock-method -->

    
      <div id="method-i-release_write_lock" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">release_write_lock</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Release a previously acquired write lock.</p>

<p>@return [Boolean] true if the lock is successfully released</p>
          
          

          
          <div class="method-source-code" id="release_write_lock-source">
            <pre><span class="ruby-comment"># File lib/concurrent/atomic/read_write_lock.rb, line 195</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">release_write_lock</span>
  <span class="ruby-identifier">c</span> = <span class="ruby-ivar">@Counter</span>.<span class="ruby-identifier">update</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">counter</span><span class="ruby-operator">|</span> <span class="ruby-identifier">counter</span><span class="ruby-operator">-</span><span class="ruby-constant">RUNNING_WRITER</span> }
  <span class="ruby-ivar">@ReadLock</span>.<span class="ruby-identifier">broadcast</span>
  <span class="ruby-ivar">@WriteLock</span>.<span class="ruby-identifier">signal</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">waiting_writers</span>(<span class="ruby-identifier">c</span>) <span class="ruby-operator">&gt;</span> <span class="ruby-value">0</span>
  <span class="ruby-keyword">true</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- release_write_lock-source -->
          
        </div>

        

        
      </div><!-- release_write_lock-method -->

    
      <div id="method-i-with_read_lock" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">with_read_lock</span><span
            class="method-args">() { || ... }</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Execute a block operation within a read lock.</p>

<p>@yield the task to be performed within the lock.</p>

<p>@return [Object] the result of the block operation.</p>

<p>@raise [ArgumentError] when no block is given. @raise
[Concurrent::ResourceLimitError] if the maximum number of readers</p>

<pre>is exceeded.</pre>
          
          

          
          <div class="method-source-code" id="with_read_lock-source">
            <pre><span class="ruby-comment"># File lib/concurrent/atomic/read_write_lock.rb, line 74</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">with_read_lock</span>
  <span class="ruby-identifier">raise</span> <span class="ruby-constant">ArgumentError</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&#39;no block given&#39;</span>) <span class="ruby-keyword">unless</span> <span class="ruby-identifier">block_given?</span>
  <span class="ruby-identifier">acquire_read_lock</span>
  <span class="ruby-keyword">begin</span>
    <span class="ruby-keyword">yield</span>
  <span class="ruby-keyword">ensure</span>
    <span class="ruby-identifier">release_read_lock</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- with_read_lock-source -->
          
        </div>

        

        
      </div><!-- with_read_lock-method -->

    
      <div id="method-i-with_write_lock" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">with_write_lock</span><span
            class="method-args">() { || ... }</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Execute a block operation within a write lock.</p>

<p>@yield the task to be performed within the lock.</p>

<p>@return [Object] the result of the block operation.</p>

<p>@raise [ArgumentError] when no block is given. @raise
[Concurrent::ResourceLimitError] if the maximum number of readers</p>

<pre>is exceeded.</pre>
          
          

          
          <div class="method-source-code" id="with_write_lock-source">
            <pre><span class="ruby-comment"># File lib/concurrent/atomic/read_write_lock.rb, line 93</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">with_write_lock</span>
  <span class="ruby-identifier">raise</span> <span class="ruby-constant">ArgumentError</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&#39;no block given&#39;</span>) <span class="ruby-keyword">unless</span> <span class="ruby-identifier">block_given?</span>
  <span class="ruby-identifier">acquire_write_lock</span>
  <span class="ruby-keyword">begin</span>
    <span class="ruby-keyword">yield</span>
  <span class="ruby-keyword">ensure</span>
    <span class="ruby-identifier">release_write_lock</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- with_write_lock-source -->
          
        </div>

        

        
      </div><!-- with_write_lock-method -->

    
      <div id="method-i-write_locked-3F" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">write_locked?</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Queries if the write lock is held by any thread.</p>

<p>@return [Boolean] true if the write lock is held else false`</p>
          
          

          
          <div class="method-source-code" id="write_locked-3F-source">
            <pre><span class="ruby-comment"># File lib/concurrent/atomic/read_write_lock.rb, line 205</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">write_locked?</span>
  <span class="ruby-ivar">@Counter</span>.<span class="ruby-identifier">value</span> <span class="ruby-operator">&gt;=</span> <span class="ruby-constant">RUNNING_WRITER</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- write_locked-3F-source -->
          
        </div>

        

        
      </div><!-- write_locked-3F-method -->

    
    </section><!-- public-instance-method-details -->
  
     <section id="private-instance-5Buntitled-5D-method-details" class="method-section section">
      <h3 class="section-header">Private Instance Methods</h3>

    
      <div id="method-i-max_readers-3F" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">max_readers?</span><span
            class="method-args">(c = @Counter.value)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>@!visibility private</p>
          
          

          
          <div class="method-source-code" id="max_readers-3F-source">
            <pre><span class="ruby-comment"># File lib/concurrent/atomic/read_write_lock.rb, line 244</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">max_readers?</span>(<span class="ruby-identifier">c</span> = <span class="ruby-ivar">@Counter</span>.<span class="ruby-identifier">value</span>)
  (<span class="ruby-identifier">c</span> <span class="ruby-operator">&amp;</span> <span class="ruby-constant">MAX_READERS</span>) <span class="ruby-operator">==</span> <span class="ruby-constant">MAX_READERS</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- max_readers-3F-source -->
          
        </div>

        

        
      </div><!-- max_readers-3F-method -->

    
      <div id="method-i-max_writers-3F" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">max_writers?</span><span
            class="method-args">(c = @Counter.value)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>@!visibility private</p>
          
          

          
          <div class="method-source-code" id="max_writers-3F-source">
            <pre><span class="ruby-comment"># File lib/concurrent/atomic/read_write_lock.rb, line 249</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">max_writers?</span>(<span class="ruby-identifier">c</span> = <span class="ruby-ivar">@Counter</span>.<span class="ruby-identifier">value</span>)
  (<span class="ruby-identifier">c</span> <span class="ruby-operator">&amp;</span> <span class="ruby-constant">MAX_WRITERS</span>) <span class="ruby-operator">==</span> <span class="ruby-constant">MAX_WRITERS</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- max_writers-3F-source -->
          
        </div>

        

        
      </div><!-- max_writers-3F-method -->

    
      <div id="method-i-running_readers" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">running_readers</span><span
            class="method-args">(c = @Counter.value)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>@!visibility private</p>
          
          

          
          <div class="method-source-code" id="running_readers-source">
            <pre><span class="ruby-comment"># File lib/concurrent/atomic/read_write_lock.rb, line 219</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">running_readers</span>(<span class="ruby-identifier">c</span> = <span class="ruby-ivar">@Counter</span>.<span class="ruby-identifier">value</span>)
  <span class="ruby-identifier">c</span> <span class="ruby-operator">&amp;</span> <span class="ruby-constant">MAX_READERS</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- running_readers-source -->
          
        </div>

        

        
      </div><!-- running_readers-method -->

    
      <div id="method-i-running_readers-3F" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">running_readers?</span><span
            class="method-args">(c = @Counter.value)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>@!visibility private</p>
          
          

          
          <div class="method-source-code" id="running_readers-3F-source">
            <pre><span class="ruby-comment"># File lib/concurrent/atomic/read_write_lock.rb, line 224</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">running_readers?</span>(<span class="ruby-identifier">c</span> = <span class="ruby-ivar">@Counter</span>.<span class="ruby-identifier">value</span>)
  (<span class="ruby-identifier">c</span> <span class="ruby-operator">&amp;</span> <span class="ruby-constant">MAX_READERS</span>) <span class="ruby-operator">&gt;</span> <span class="ruby-value">0</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- running_readers-3F-source -->
          
        </div>

        

        
      </div><!-- running_readers-3F-method -->

    
      <div id="method-i-running_writer-3F" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">running_writer?</span><span
            class="method-args">(c = @Counter.value)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>@!visibility private</p>
          
          

          
          <div class="method-source-code" id="running_writer-3F-source">
            <pre><span class="ruby-comment"># File lib/concurrent/atomic/read_write_lock.rb, line 229</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">running_writer?</span>(<span class="ruby-identifier">c</span> = <span class="ruby-ivar">@Counter</span>.<span class="ruby-identifier">value</span>)
  <span class="ruby-identifier">c</span> <span class="ruby-operator">&gt;=</span> <span class="ruby-constant">RUNNING_WRITER</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- running_writer-3F-source -->
          
        </div>

        

        
      </div><!-- running_writer-3F-method -->

    
      <div id="method-i-waiting_writer-3F" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">waiting_writer?</span><span
            class="method-args">(c = @Counter.value)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>@!visibility private</p>
          
          

          
          <div class="method-source-code" id="waiting_writer-3F-source">
            <pre><span class="ruby-comment"># File lib/concurrent/atomic/read_write_lock.rb, line 239</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">waiting_writer?</span>(<span class="ruby-identifier">c</span> = <span class="ruby-ivar">@Counter</span>.<span class="ruby-identifier">value</span>)
  <span class="ruby-identifier">c</span> <span class="ruby-operator">&gt;=</span> <span class="ruby-constant">WAITING_WRITER</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- waiting_writer-3F-source -->
          
        </div>

        

        
      </div><!-- waiting_writer-3F-method -->

    
      <div id="method-i-waiting_writers" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">waiting_writers</span><span
            class="method-args">(c = @Counter.value)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>@!visibility private</p>
          
          

          
          <div class="method-source-code" id="waiting_writers-source">
            <pre><span class="ruby-comment"># File lib/concurrent/atomic/read_write_lock.rb, line 234</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">waiting_writers</span>(<span class="ruby-identifier">c</span> = <span class="ruby-ivar">@Counter</span>.<span class="ruby-identifier">value</span>)
  (<span class="ruby-identifier">c</span> <span class="ruby-operator">&amp;</span> <span class="ruby-constant">MAX_WRITERS</span>) <span class="ruby-operator">/</span> <span class="ruby-constant">WAITING_WRITER</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- waiting_writers-source -->
          
        </div>

        

        
      </div><!-- waiting_writers-method -->

    
    </section><!-- private-instance-method-details -->
  
  </section><!-- 5Buntitled-5D -->

</div><!-- documentation -->


<footer id="validator-badges">
  <p><a href="http://validator.w3.org/check/referer">[Validate]</a>
  <p>Generated by <a href="https://github.com/rdoc/rdoc">RDoc</a> 4.0.0.
  <p>Generated with the <a href="http://deveiate.org/projects/Darkfish-Rdoc/">Darkfish Rdoc Generator</a> 3.
</footer>

