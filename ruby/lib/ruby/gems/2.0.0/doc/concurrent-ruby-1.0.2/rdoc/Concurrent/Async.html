<!DOCTYPE html>

<html>
<head>
<meta content="text/html; charset=UTF-8" http-equiv="Content-Type">

<title>module Concurrent::Async - concurrent-ruby-1.0.2 Documentation</title>

<link type="text/css" media="screen" href="../rdoc.css" rel="stylesheet">

<script type="text/javascript">
  var rdoc_rel_prefix = "../";
</script>

<script type="text/javascript" charset="utf-8" src="../js/jquery.js"></script>
<script type="text/javascript" charset="utf-8" src="../js/navigation.js"></script>
<script type="text/javascript" charset="utf-8" src="../js/search_index.js"></script>
<script type="text/javascript" charset="utf-8" src="../js/search.js"></script>
<script type="text/javascript" charset="utf-8" src="../js/searcher.js"></script>
<script type="text/javascript" charset="utf-8" src="../js/darkfish.js"></script>


<body id="top" class="module">
<nav id="metadata">
  <nav id="home-section" class="section">
  <h3 class="section-header">
    <a href="../index.html">Home</a>
    <a href="../table_of_contents.html#classes">Classes</a>
    <a href="../table_of_contents.html#methods">Methods</a>
  </h3>
</nav>


  <nav id="search-section" class="section project-section" class="initially-hidden">
  <form action="#" method="get" accept-charset="utf-8">
    <h3 class="section-header">
      <input type="text" name="search" placeholder="Search" id="search-field"
             title="Type to search, Up and Down to navigate, Enter to load">
    </h3>
  </form>

  <ul id="search-results" class="initially-hidden"></ul>
</nav>


  

  <div id="file-metadata">
    <nav id="file-list-section" class="section">
  <h3 class="section-header">Defined In</h3>
  <ul>
    <li>lib/concurrent/async.rb
  </ul>
</nav>

    
  </div>

  <div id="class-metadata">
    
    
    
    <!-- Extension Modules -->
<nav id="extends-section" class="section">
  <h3 class="section-header">Extended With Modules</h3>

  <ul class="link-list">
    
  
    <li><a class="extend" href="Async/ClassMethods.html">Concurrent::Async::ClassMethods</a>
  
  
  </ul>
</nav>

    <!-- Method Quickref -->
<nav id="method-list-section" class="section">
  <h3 class="section-header">Methods</h3>

  <ul class="link-list">
    
    <li class="calls-super" ><a href="#method-c-included">::included</a>
    
    <li ><a href="#method-c-validate_argc">::validate_argc</a>
    
    <li ><a href="#method-i-async">#async</a>
    
    <li ><a href="#method-i-await">#await</a>
    
    <li ><a href="#method-i-call">#call</a>
    
    <li ><a href="#method-i-cast">#cast</a>
    
    <li ><a href="#method-i-init_synchronization">#init_synchronization</a>
    
  </ul>
</nav>

  </div>

  <div id="project-metadata">
    <nav id="fileindex-section" class="section project-section">
  <h3 class="section-header">Pages</h3>

  <ul>
  
    <li class="file"><a href="../CHANGELOG_md.html">CHANGELOG</a>
  
    <li class="file"><a href="../LICENSE_txt.html">LICENSE</a>
  
    <li class="file"><a href="../README_md.html">README</a>
  
  </ul>
</nav>

    <nav id="classindex-section" class="section project-section">
  <h3 class="section-header">Class and Module Index</h3>

  <ul class="link-list">
  
    <li><a href="../Concurrent.html">Concurrent</a>
  
    <li><a href="../Concurrent/AbstractExchanger.html">Concurrent::AbstractExchanger</a>
  
    <li><a href="../Concurrent/AbstractExecutorService.html">Concurrent::AbstractExecutorService</a>
  
    <li><a href="../Concurrent/AbstractThreadLocalVar.html">Concurrent::AbstractThreadLocalVar</a>
  
    <li><a href="../Concurrent/Agent.html">Concurrent::Agent</a>
  
    <li><a href="../Concurrent/Agent/Error.html">Concurrent::Agent::Error</a>
  
    <li><a href="../Concurrent/Agent/ValidationError.html">Concurrent::Agent::ValidationError</a>
  
    <li><a href="../Concurrent/Array.html">Concurrent::Array</a>
  
    <li><a href="../Concurrent/Async.html">Concurrent::Async</a>
  
    <li><a href="../Concurrent/Async/AsyncDelegator.html">Concurrent::Async::AsyncDelegator</a>
  
    <li><a href="../Concurrent/Async/AwaitDelegator.html">Concurrent::Async::AwaitDelegator</a>
  
    <li><a href="../Concurrent/Async/ClassMethods.html">Concurrent::Async::ClassMethods</a>
  
    <li><a href="../Concurrent/AtExitImplementation.html">Concurrent::AtExitImplementation</a>
  
    <li><a href="../Concurrent/Atom.html">Concurrent::Atom</a>
  
    <li><a href="../Concurrent/AtomicBoolean.html">Concurrent::AtomicBoolean</a>
  
    <li><a href="../Concurrent/AtomicDirectUpdate.html">Concurrent::AtomicDirectUpdate</a>
  
    <li><a href="../Concurrent/AtomicFixnum.html">Concurrent::AtomicFixnum</a>
  
    <li><a href="../Concurrent/AtomicNumericCompareAndSetWrapper.html">Concurrent::AtomicNumericCompareAndSetWrapper</a>
  
    <li><a href="../Concurrent/AtomicReference.html">Concurrent::AtomicReference</a>
  
    <li><a href="../Concurrent/CAtomicReference.html">Concurrent::CAtomicReference</a>
  
    <li><a href="../Concurrent/CachedThreadPool.html">Concurrent::CachedThreadPool</a>
  
    <li><a href="../Concurrent/Collection.html">Concurrent::Collection</a>
  
    <li><a href="../Concurrent/Collection/AtomicReferenceMapBackend.html">Concurrent::Collection::AtomicReferenceMapBackend</a>
  
    <li><a href="../Concurrent/Collection/AtomicReferenceMapBackend/Node.html">Concurrent::Collection::AtomicReferenceMapBackend::Node</a>
  
    <li><a href="../Concurrent/Collection/AtomicReferenceMapBackend/Table.html">Concurrent::Collection::AtomicReferenceMapBackend::Table</a>
  
    <li><a href="../Concurrent/Collection/CopyOnNotifyObserverSet.html">Concurrent::Collection::CopyOnNotifyObserverSet</a>
  
    <li><a href="../Concurrent/Collection/CopyOnWriteObserverSet.html">Concurrent::Collection::CopyOnWriteObserverSet</a>
  
    <li><a href="../Concurrent/Collection/JavaNonConcurrentPriorityQueue.html">Concurrent::Collection::JavaNonConcurrentPriorityQueue</a>
  
    <li><a href="../Concurrent/Collection/MriMapBackend.html">Concurrent::Collection::MriMapBackend</a>
  
    <li><a href="../Concurrent/Collection/NonConcurrentMapBackend.html">Concurrent::Collection::NonConcurrentMapBackend</a>
  
    <li><a href="../Concurrent/Collection/NonConcurrentPriorityQueue.html">Concurrent::Collection::NonConcurrentPriorityQueue</a>
  
    <li><a href="../Concurrent/Collection/RubyNonConcurrentPriorityQueue.html">Concurrent::Collection::RubyNonConcurrentPriorityQueue</a>
  
    <li><a href="../Concurrent/Collection/SynchronizedMapBackend.html">Concurrent::Collection::SynchronizedMapBackend</a>
  
    <li><a href="../Concurrent/Concern.html">Concurrent::Concern</a>
  
    <li><a href="../Concurrent/Concern/Deprecation.html">Concurrent::Concern::Deprecation</a>
  
    <li><a href="../Concurrent/Concern/Dereferenceable.html">Concurrent::Concern::Dereferenceable</a>
  
    <li><a href="../Concurrent/Concern/Logging.html">Concurrent::Concern::Logging</a>
  
    <li><a href="../Concurrent/Concern/Obligation.html">Concurrent::Concern::Obligation</a>
  
    <li><a href="../Concurrent/Concern/Observable.html">Concurrent::Concern::Observable</a>
  
    <li><a href="../Concurrent/ConcurrentUpdateError.html">Concurrent::ConcurrentUpdateError</a>
  
    <li><a href="../Concurrent/CountDownLatch.html">Concurrent::CountDownLatch</a>
  
    <li><a href="../Concurrent/CyclicBarrier.html">Concurrent::CyclicBarrier</a>
  
    <li><a href="../Concurrent/Delay.html">Concurrent::Delay</a>
  
    <li><a href="../Concurrent/DependencyCounter.html">Concurrent::DependencyCounter</a>
  
    <li><a href="../Concurrent/Edge.html">Concurrent::Edge</a>
  
    <li><a href="../Concurrent/Event.html">Concurrent::Event</a>
  
    <li><a href="../Concurrent/Exchanger.html">Concurrent::Exchanger</a>
  
    <li><a href="../Concurrent/ExecutorService.html">Concurrent::ExecutorService</a>
  
    <li><a href="../Concurrent/FixedThreadPool.html">Concurrent::FixedThreadPool</a>
  
    <li><a href="../Concurrent/Future.html">Concurrent::Future</a>
  
    <li><a href="../Concurrent/Hash.html">Concurrent::Hash</a>
  
    <li><a href="../Concurrent/IVar.html">Concurrent::IVar</a>
  
    <li><a href="../Concurrent/ImmediateExecutor.html">Concurrent::ImmediateExecutor</a>
  
    <li><a href="../Concurrent/ImmutableStruct.html">Concurrent::ImmutableStruct</a>
  
    <li><a href="../Concurrent/IndirectImmediateExecutor.html">Concurrent::IndirectImmediateExecutor</a>
  
    <li><a href="../Concurrent/JavaAtomicReference.html">Concurrent::JavaAtomicReference</a>
  
    <li><a href="../Concurrent/JavaCountDownLatch.html">Concurrent::JavaCountDownLatch</a>
  
    <li><a href="../Concurrent/JavaExchanger.html">Concurrent::JavaExchanger</a>
  
    <li><a href="../Concurrent/JavaExecutorService.html">Concurrent::JavaExecutorService</a>
  
    <li><a href="../Concurrent/JavaExecutorService/Job.html">Concurrent::JavaExecutorService::Job</a>
  
    <li><a href="../Concurrent/JavaSingleThreadExecutor.html">Concurrent::JavaSingleThreadExecutor</a>
  
    <li><a href="../Concurrent/JavaThreadLocalVar.html">Concurrent::JavaThreadLocalVar</a>
  
    <li><a href="../Concurrent/JavaThreadPoolExecutor.html">Concurrent::JavaThreadPoolExecutor</a>
  
    <li><a href="../Concurrent/LazyRegister.html">Concurrent::LazyRegister</a>
  
    <li><a href="../Concurrent/MVar.html">Concurrent::MVar</a>
  
    <li><a href="../Concurrent/Map.html">Concurrent::Map</a>
  
    <li><a href="../Concurrent/Maybe.html">Concurrent::Maybe</a>
  
    <li><a href="../Concurrent/MutableStruct.html">Concurrent::MutableStruct</a>
  
    <li><a href="../Concurrent/MutexAtomicBoolean.html">Concurrent::MutexAtomicBoolean</a>
  
    <li><a href="../Concurrent/MutexAtomicFixnum.html">Concurrent::MutexAtomicFixnum</a>
  
    <li><a href="../Concurrent/MutexAtomicReference.html">Concurrent::MutexAtomicReference</a>
  
    <li><a href="../Concurrent/MutexCountDownLatch.html">Concurrent::MutexCountDownLatch</a>
  
    <li><a href="../Concurrent/MutexSemaphore.html">Concurrent::MutexSemaphore</a>
  
    <li><a href="../Concurrent/Options.html">Concurrent::Options</a>
  
    <li><a href="../Concurrent/Process.html">Concurrent::Process</a>
  
    <li><a href="../Concurrent/Promise.html">Concurrent::Promise</a>
  
    <li><a href="../Concurrent/RbxAtomicReference.html">Concurrent::RbxAtomicReference</a>
  
    <li><a href="../Concurrent/ReadWriteLock.html">Concurrent::ReadWriteLock</a>
  
    <li><a href="../Concurrent/ReentrantReadWriteLock.html">Concurrent::ReentrantReadWriteLock</a>
  
    <li><a href="../Concurrent/RubyExchanger.html">Concurrent::RubyExchanger</a>
  
    <li><a href="../Concurrent/RubyExchanger/Node.html">Concurrent::RubyExchanger::Node</a>
  
    <li><a href="../Concurrent/RubyExecutorService.html">Concurrent::RubyExecutorService</a>
  
    <li><a href="../Concurrent/RubySingleThreadExecutor.html">Concurrent::RubySingleThreadExecutor</a>
  
    <li><a href="../Concurrent/RubyThreadLocalVar.html">Concurrent::RubyThreadLocalVar</a>
  
    <li><a href="../Concurrent/RubyThreadPoolExecutor.html">Concurrent::RubyThreadPoolExecutor</a>
  
    <li><a href="../Concurrent/RubyThreadPoolExecutor/Worker.html">Concurrent::RubyThreadPoolExecutor::Worker</a>
  
    <li><a href="../Concurrent/SafeTaskExecutor.html">Concurrent::SafeTaskExecutor</a>
  
    <li><a href="../Concurrent/ScheduledTask.html">Concurrent::ScheduledTask</a>
  
    <li><a href="../Concurrent/Semaphore.html">Concurrent::Semaphore</a>
  
    <li><a href="../Concurrent/SerialExecutorService.html">Concurrent::SerialExecutorService</a>
  
    <li><a href="../Concurrent/SerializedExecution.html">Concurrent::SerializedExecution</a>
  
    <li><a href="../Concurrent/SerializedExecutionDelegator.html">Concurrent::SerializedExecutionDelegator</a>
  
    <li><a href="../Concurrent/SettableStruct.html">Concurrent::SettableStruct</a>
  
    <li><a href="../Concurrent/SimpleExecutorService.html">Concurrent::SimpleExecutorService</a>
  
    <li><a href="../Concurrent/SingleThreadExecutor.html">Concurrent::SingleThreadExecutor</a>
  
    <li><a href="../Concurrent/Synchronization.html">Concurrent::Synchronization</a>
  
    <li><a href="../Concurrent/Synchronization/AbstractLockableObject.html">Concurrent::Synchronization::AbstractLockableObject</a>
  
    <li><a href="../Concurrent/Synchronization/AbstractObject.html">Concurrent::Synchronization::AbstractObject</a>
  
    <li><a href="../Concurrent/Synchronization/AbstractStruct.html">Concurrent::Synchronization::AbstractStruct</a>
  
    <li><a href="../Concurrent/Synchronization/Condition.html">Concurrent::Synchronization::Condition</a>
  
    <li><a href="../Concurrent/Synchronization/JRubyAttrVolatile.html">Concurrent::Synchronization::JRubyAttrVolatile</a>
  
    <li><a href="../Concurrent/Synchronization/JRubyAttrVolatile/ClassMethods.html">Concurrent::Synchronization::JRubyAttrVolatile::ClassMethods</a>
  
    <li><a href="../Concurrent/Synchronization/JRubyLockableObject.html">Concurrent::Synchronization::JRubyLockableObject</a>
  
    <li><a href="../Concurrent/Synchronization/JRubyObject.html">Concurrent::Synchronization::JRubyObject</a>
  
    <li><a href="../Concurrent/Synchronization/Lock.html">Concurrent::Synchronization::Lock</a>
  
    <li><a href="../Concurrent/Synchronization/LockableObject.html">Concurrent::Synchronization::LockableObject</a>
  
    <li><a href="../Concurrent/Synchronization/MriAttrVolatile.html">Concurrent::Synchronization::MriAttrVolatile</a>
  
    <li><a href="../Concurrent/Synchronization/MriAttrVolatile/ClassMethods.html">Concurrent::Synchronization::MriAttrVolatile::ClassMethods</a>
  
    <li><a href="../Concurrent/Synchronization/MriLockableObject.html">Concurrent::Synchronization::MriLockableObject</a>
  
    <li><a href="../Concurrent/Synchronization/MriMonitorLockableObject.html">Concurrent::Synchronization::MriMonitorLockableObject</a>
  
    <li><a href="../Concurrent/Synchronization/MriMutexLockableObject.html">Concurrent::Synchronization::MriMutexLockableObject</a>
  
    <li><a href="../Concurrent/Synchronization/MriObject.html">Concurrent::Synchronization::MriObject</a>
  
    <li><a href="../Concurrent/Synchronization/Object.html">Concurrent::Synchronization::Object</a>
  
    <li><a href="../Concurrent/Synchronization/RbxAttrVolatile.html">Concurrent::Synchronization::RbxAttrVolatile</a>
  
    <li><a href="../Concurrent/Synchronization/RbxAttrVolatile/ClassMethods.html">Concurrent::Synchronization::RbxAttrVolatile::ClassMethods</a>
  
    <li><a href="../Concurrent/Synchronization/RbxLockableObject.html">Concurrent::Synchronization::RbxLockableObject</a>
  
    <li><a href="../Concurrent/Synchronization/RbxObject.html">Concurrent::Synchronization::RbxObject</a>
  
    <li><a href="../Concurrent/Synchronization/TruffleAttrVolatile.html">Concurrent::Synchronization::TruffleAttrVolatile</a>
  
    <li><a href="../Concurrent/Synchronization/TruffleAttrVolatile/ClassMethods.html">Concurrent::Synchronization::TruffleAttrVolatile::ClassMethods</a>
  
    <li><a href="../Concurrent/Synchronization/TruffleLockableObject.html">Concurrent::Synchronization::TruffleLockableObject</a>
  
    <li><a href="../Concurrent/Synchronization/TruffleObject.html">Concurrent::Synchronization::TruffleObject</a>
  
    <li><a href="../Concurrent/SynchronizedDelegator.html">Concurrent::SynchronizedDelegator</a>
  
    <li><a href="../Concurrent/TVar.html">Concurrent::TVar</a>
  
    <li><a href="../Concurrent/ThreadLocalVar.html">Concurrent::ThreadLocalVar</a>
  
    <li><a href="../Concurrent/ThreadPoolExecutor.html">Concurrent::ThreadPoolExecutor</a>
  
    <li><a href="../Concurrent/ThreadSafe.html">Concurrent::ThreadSafe</a>
  
    <li><a href="../Concurrent/ThreadSafe/Util.html">Concurrent::ThreadSafe::Util</a>
  
    <li><a href="../Concurrent/ThreadSafe/Util/Adder.html">Concurrent::ThreadSafe::Util::Adder</a>
  
    <li><a href="../Concurrent/ThreadSafe/Util/CheapLockable.html">Concurrent::ThreadSafe::Util::CheapLockable</a>
  
    <li><a href="../Concurrent/ThreadSafe/Util/PowerOfTwoTuple.html">Concurrent::ThreadSafe::Util::PowerOfTwoTuple</a>
  
    <li><a href="../Concurrent/ThreadSafe/Util/Striped64.html">Concurrent::ThreadSafe::Util::Striped64</a>
  
    <li><a href="../Concurrent/ThreadSafe/Util/Striped64/Cell.html">Concurrent::ThreadSafe::Util::Striped64::Cell</a>
  
    <li><a href="../Concurrent/ThreadSafe/Util/Volatile.html">Concurrent::ThreadSafe::Util::Volatile</a>
  
    <li><a href="../Concurrent/ThreadSafe/Util/XorShiftRandom.html">Concurrent::ThreadSafe::Util::XorShiftRandom</a>
  
    <li><a href="../Concurrent/TimerSet.html">Concurrent::TimerSet</a>
  
    <li><a href="../Concurrent/TimerTask.html">Concurrent::TimerTask</a>
  
    <li><a href="../Concurrent/Transaction.html">Concurrent::Transaction</a>
  
    <li><a href="../Concurrent/Tuple.html">Concurrent::Tuple</a>
  
    <li><a href="../Concurrent/Utility.html">Concurrent::Utility</a>
  
    <li><a href="../Concurrent/Utility/EngineDetector.html">Concurrent::Utility::EngineDetector</a>
  
    <li><a href="../Concurrent/Utility/NativeExtensionLoader.html">Concurrent::Utility::NativeExtensionLoader</a>
  
    <li><a href="../Concurrent/Utility/ProcessorCounter.html">Concurrent::Utility::ProcessorCounter</a>
  
  </ul>
</nav>

  </div>
</nav>

<div id="documentation">
  <h1 class="module">module Concurrent::Async</h1>

  <div id="description" class="description">
    
<p>A mixin module that provides simple asynchronous behavior to a class,
turning it into a simple actor. Loosely based on Erlang&#39;s
[gen_server](<a
href="http://www.erlang.org/doc/man/gen_server.html">www.erlang.org/doc/man/gen_server.html</a>),
but without supervision or linking.</p>

<p>A more feature-rich {Concurrent::Actor} is also available when the
capabilities of `Async` are too limited.</p>

<p>“`cucumber Feature:</p>

<pre>As a stateful, plain old Ruby class
I want safe, asynchronous behavior
So my long-running methods don&#39;t block the main thread</pre>

<p>“`</p>

<p>The `Async` module is a way to mix simple yet powerful asynchronous
capabilities into any plain old Ruby object or class, turning each object
into a simple Actor. Method calls are processed on a background thread. The
caller is free to perform other actions while processing occurs in the
background.</p>

<p>Method calls to the asynchronous object are made via two proxy methods:
`async` (alias `cast`) and `await` (alias `call`). These proxy methods post
the method call to the object&#39;s background thread and return a “future”
which will eventually contain the result of the method call.</p>

<p>This behavior is loosely patterned after Erlang&#39;s `gen_server`
behavior. When an Erlang module implements the `gen_server` behavior it
becomes inherently asynchronous. The `start` or `start_link` function
spawns a process (similar to a thread but much more lightweight and
efficient) and reurns the ID of the process. Using the process ID, other
processes can send messages to the `gen_server` via the `cast` and `call`
methods. Unlike Erlang&#39;s `gen_server`, however, `Async` classes do not
support linking or supervision trees.</p>

<p>## Basic Usage</p>

<p>When this module is mixed into a class, objects of the class become
inherently asynchronous. Each object gets its own background thread on
which to post asynchronous method calls. Asynchronous method calls are
executed in the background one at a time in the order they are received.</p>

<p>To create an asynchronous class, simply mix in the `Concurrent::Async`
module:</p>

<p>“` class Hello</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-constant">Concurrent</span><span class="ruby-operator">::</span><span class="ruby-constant">Async</span>

<span class="ruby-keyword">def</span> <span class="ruby-identifier">hello</span>(<span class="ruby-identifier">name</span>)
  <span class="ruby-node">&quot;Hello, #{name}!&quot;</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end “`</p>

<p>When defining a constructor it is critical that the first line be a call to
`super` with no arguments. The `super` method initializes the background
thread and other asynchronous components.</p>

<p>“` class BackgroundLogger</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-constant">Concurrent</span><span class="ruby-operator">::</span><span class="ruby-constant">Async</span>

<span class="ruby-keyword">def</span> <span class="ruby-identifier">initialize</span>(<span class="ruby-identifier">level</span>)
  <span class="ruby-keyword">super</span>()
  <span class="ruby-ivar">@logger</span> = <span class="ruby-constant">Logger</span>.<span class="ruby-identifier">new</span>(<span class="ruby-constant">STDOUT</span>)
  <span class="ruby-ivar">@logger</span>.<span class="ruby-identifier">level</span> = <span class="ruby-identifier">level</span>
<span class="ruby-keyword">end</span>

<span class="ruby-keyword">def</span> <span class="ruby-identifier">info</span>(<span class="ruby-identifier">msg</span>)
  <span class="ruby-ivar">@logger</span>.<span class="ruby-identifier">info</span>(<span class="ruby-identifier">msg</span>)
<span class="ruby-keyword">end</span>
</pre>

<p>end “`</p>

<p>Mixing this module into a class provides each object two proxy methods:
`async` and `await`. These methods are thread safe with respect to the
enclosing object. The former proxy allows methods to be called
asynchronously by posting to the object&#39;s internal thread. The latter
proxy allows a method to be called synchronously but does so safely with
respect to any pending asynchronous method calls and ensures proper
ordering. Both methods return a {Concurrent::IVar} which can be inspected
for the result of the proxied method call. Calling a method with `async`
will return a `:pending` `IVar` whereas `await` will return a `:complete`
`IVar`.</p>

<p>“` class Echo</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-constant">Concurrent</span><span class="ruby-operator">::</span><span class="ruby-constant">Async</span>

<span class="ruby-keyword">def</span> <span class="ruby-identifier">echo</span>(<span class="ruby-identifier">msg</span>)
  <span class="ruby-identifier">print</span> <span class="ruby-node">&quot;#{msg}\n&quot;</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p>horn = Echo.new horn.echo(&#39;zero&#39;)      # synchronous, not
thread-safe</p>

<pre># returns the actual return value of the method</pre>

<p>horn.async.echo(&#39;one&#39;) # asynchronous, non-blocking, thread-safe</p>

<pre># returns an IVar in the :pending state</pre>

<p>horn.await.echo(&#39;two&#39;) # synchronous, blocking, thread-safe</p>

<pre># returns an IVar in the :complete state</pre>

<p>“`</p>

<p>## Let It Fail</p>

<p>The `async` and `await` proxy methods have built-in error protection based
on Erlang&#39;s famous “let it fail” philosophy. Instance methods should
not be programmed defensively. When an exception is raised by a delegated
method the proxy will rescue the exception, expose it to the caller as the
`reason` attribute of the returned future, then process the next method
call.</p>

<p>## Calling Methods Internally</p>

<p>External method calls should <strong>always</strong> use the `async` and
`await` proxy methods. When one method calls another method, the `async`
proxy should rarely be used and the `await` proxy should
<strong>never</strong> be used.</p>

<p>When an object calls one of its own methods using the `await` proxy the
second call will be enqueued <strong>behind</strong> the currently running
method call. Any attempt to wait on the result will fail as the second call
will never run until after the current call completes.</p>

<p>Calling a method using the `await` proxy from within a method that was
itself called using `async` or `await` will irreversibly deadlock the
object. Do <strong>not</strong> do this, ever.</p>

<p>## Instance Variables and Attribute Accessors</p>

<p>Instance variables do not need to be thread-safe so long as they are
private. Asynchronous method calls are processed in the order they are
received and are processed one at a time. Therefore private instance
variables can only be accessed by one thread at a time. This is inherently
thread-safe.</p>

<p>When using private instance variables within asynchronous methods, the best
practice is to read the instance variable into a local variable at the
start of the method then update the instance variable at the
<strong>end</strong> of the method. This way, should an exception be raised
during method execution the internal state of the boject will not have been
changed.</p>

<p>### Reader Attributes</p>

<p>The use of `attr_reader` is discouraged. Internal state exposed externally,
when necessary, should be done through accessor methods. The instance
variables exposed by these methods <strong>must</strong> be thread-safe, or
they must be called using the `async` and `await` proxy methods. These two
approaches are subtly different.</p>

<p>When internal state is accessed via the `async` and `await` proxy methods,
the returned value represents the object&#39;s state *at the time the call
is processed*, which may <strong>not</strong> be the state of the object at
the time the call is made.</p>

<p>To get the state *at the current* time, irrespective of an enqueued method
calls, a reader method must be called directly. This is inherently unsafe
unless the instance variable is itself thread-safe, preferrably using one
of the thread-safe classes within this library. Because the thread-safe
classes within this library are internally-locking or non-locking, they can
be safely used from within asynchronous methods without causing deadlocks.</p>

<p>Generally speaking, the best practice is to <strong>not</strong> expose
internal state via reader methods. The best practice is to simply use the
method&#39;s return value.</p>

<p>### Writer Attributes</p>

<p>Writer attributes should never be used with asynchronous classes. Changing
the state externally, even when done in the thread-safe way, is not
logically consistent. Changes to state need to be timed with respect to all
asynchronous method calls which my be in-process or enqueued. The only safe
practice is to pass all necessary data to each method as arguments and let
the method update the internal state as necessary.</p>

<p>## Class Constants, Variables, and Methods</p>

<p>### Class Constants</p>

<p>Class constants do not need to be thread-safe. Since they are read-only and
immutable they may be safely read both externally and from within
asynchronous methods.</p>

<p>### Class Variables</p>

<p>Class variables should be avoided. Class variables represent shared state.
Shared state is anathema to concurrency. Should there be a need to share
state using class variables they <strong>must</strong> be thread-safe,
preferrably using the thread-safe classes within this library. When
updating class variables, never assign a new value/object to the variable
itself. Assignment is not thread-safe in Ruby. Instead, use the thread-safe
update functions of the variable itself to change the value.</p>

<p>The best practice is to <strong>never</strong> use class variables with
`Async` classes.</p>

<p>### Class Methods</p>

<p>Class methods which are pure functions are safe. Class methods which modify
class variables should be avoided, for all the reasons listed above.</p>

<p>## An Important Note About Thread Safe Guarantees</p>

<p>&gt; Thread safe guarantees can only be made when asynchronous method calls
&gt; are not mixed with direct method calls. Use only direct method calls
&gt; when the object is used exclusively on a single thread. Use only &gt;
`async` and `await` when the object is shared between threads. Once you
&gt; call a method using `async` or `await`, you should no longer call
methods &gt; directly on the object. Use `async` and `await` exclusively
from then on.</p>

<p>@example</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Echo</span>
  <span class="ruby-identifier">include</span> <span class="ruby-constant">Concurrent</span><span class="ruby-operator">::</span><span class="ruby-constant">Async</span>

  <span class="ruby-keyword">def</span> <span class="ruby-identifier">echo</span>(<span class="ruby-identifier">msg</span>)
    <span class="ruby-identifier">print</span> <span class="ruby-node">&quot;#{msg}\n&quot;</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>

<span class="ruby-identifier">horn</span> = <span class="ruby-constant">Echo</span>.<span class="ruby-identifier">new</span>
<span class="ruby-identifier">horn</span>.<span class="ruby-identifier">echo</span>(<span class="ruby-string">&#39;zero&#39;</span>)      <span class="ruby-comment"># synchronous, not thread-safe</span>
                       <span class="ruby-comment"># returns the actual return value of the method</span>

<span class="ruby-identifier">horn</span>.<span class="ruby-identifier">async</span>.<span class="ruby-identifier">echo</span>(<span class="ruby-string">&#39;one&#39;</span>) <span class="ruby-comment"># asynchronous, non-blocking, thread-safe</span>
                       <span class="ruby-comment"># returns an IVar in the :pending state</span>

<span class="ruby-identifier">horn</span>.<span class="ruby-identifier">await</span>.<span class="ruby-identifier">echo</span>(<span class="ruby-string">&#39;two&#39;</span>) <span class="ruby-comment"># synchronous, blocking, thread-safe</span>
                       <span class="ruby-comment"># returns an IVar in the :complete state</span>
</pre>

<p>@see Concurrent::Actor @see <a
href="https://en.wikipedia.org/wiki/Actor_model">en.wikipedia.org/wiki/Actor_model</a>
“Actor Model” at Wikipedia @see <a
href="http://www.erlang.org/doc/man/gen_server.html">www.erlang.org/doc/man/gen_server.html</a>
Erlang gen_server @see <a
href="http://c2.com/cgi/wiki?LetItCrash">c2.com/cgi/wiki?LetItCrash</a>
“Let It Crash” at <a href="http://c2.com">c2.com</a>/</p>

  </div><!-- description -->

  
  
  
  <section id="5Buntitled-5D" class="documentation-section">
    

    

    

    

    <!-- Methods -->
    
     <section id="public-class-5Buntitled-5D-method-details" class="method-section section">
      <h3 class="section-header">Public Class Methods</h3>

    
      <div id="method-c-included" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">included</span><span
            class="method-args">(base)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>@!visibility private</p>
          
          
            <div class="method-calls-super">
              Calls superclass method
              
            </div>
          

          
          <div class="method-source-code" id="included-source">
            <pre><span class="ruby-comment"># File lib/concurrent/async.rb, line 282</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">included</span>(<span class="ruby-identifier">base</span>)
  <span class="ruby-identifier">base</span>.<span class="ruby-identifier">singleton_class</span>.<span class="ruby-identifier">send</span>(<span class="ruby-value">:alias_method</span>, <span class="ruby-value">:original_new</span>, <span class="ruby-value">:new</span>)
  <span class="ruby-identifier">base</span>.<span class="ruby-identifier">extend</span>(<span class="ruby-constant">ClassMethods</span>)
  <span class="ruby-keyword">super</span>(<span class="ruby-identifier">base</span>)
<span class="ruby-keyword">end</span></pre>
          </div><!-- included-source -->
          
        </div>

        

        
      </div><!-- included-method -->

    
      <div id="method-c-validate_argc" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">validate_argc</span><span
            class="method-args">(obj, method, *args)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Check for the presence of a method on an object and determine if a given
set of arguments matches the required arity.</p>

<p>@param [Object] obj the object to check against @param [Symbol] method the
method to check the object for @param [Array] args zero or more arguments
for the arity check</p>

<p>@raise [NameError] the object does not respond to `method` method @raise
[ArgumentError] the given `args` do not match the arity of `method`</p>

<p>@note This check is imperfect because of the way Ruby reports the arity of</p>

<pre>methods with a variable number of arguments. It is possible to determine
if too few arguments are given but impossible to determine if too many
arguments are given. This check may also fail to recognize dynamic behavior
of the object, such as methods simulated with `method_missing`.</pre>

<p>@see <a
href="http://www.ruby-doc.org/core-2.1.1/Method.html#method-i-arity">www.ruby-doc.org/core-2.1.1/Method.html#method-i-arity</a>
Method#arity @see <a
href="http://ruby-doc.org/core-2.1.0/Object.html#method-i-respond_to-3F">ruby-doc.org/core-2.1.0/Object.html#method-i-respond_to-3F</a>
Object#respond_to? @see <a
href="http://www.ruby-doc.org/core-2.1.0/BasicObject.html#method-i-method_missing">www.ruby-doc.org/core-2.1.0/BasicObject.html#method-i-method_missing</a>
BasicObject#method_missing</p>

<p>@!visibility private</p>
          
          

          
          <div class="method-source-code" id="validate_argc-source">
            <pre><span class="ruby-comment"># File lib/concurrent/async.rb, line 270</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">validate_argc</span>(<span class="ruby-identifier">obj</span>, <span class="ruby-identifier">method</span>, <span class="ruby-operator">*</span><span class="ruby-identifier">args</span>)
  <span class="ruby-identifier">argc</span> = <span class="ruby-identifier">args</span>.<span class="ruby-identifier">length</span>
  <span class="ruby-identifier">arity</span> = <span class="ruby-identifier">obj</span>.<span class="ruby-identifier">method</span>(<span class="ruby-identifier">method</span>).<span class="ruby-identifier">arity</span>

  <span class="ruby-keyword">if</span> <span class="ruby-identifier">arity</span> <span class="ruby-operator">&gt;=</span> <span class="ruby-value">0</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">argc</span> <span class="ruby-operator">!=</span> <span class="ruby-identifier">arity</span>
    <span class="ruby-identifier">raise</span> <span class="ruby-constant">ArgumentError</span>.<span class="ruby-identifier">new</span>(<span class="ruby-node">&quot;wrong number of arguments (#{argc} for #{arity})&quot;</span>)
  <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">arity</span> <span class="ruby-operator">&lt;</span> <span class="ruby-value">0</span> <span class="ruby-operator">&amp;&amp;</span> (<span class="ruby-identifier">arity</span> = (<span class="ruby-identifier">arity</span> <span class="ruby-operator">+</span> <span class="ruby-value">1</span>).<span class="ruby-identifier">abs</span>) <span class="ruby-operator">&gt;</span> <span class="ruby-identifier">argc</span>
    <span class="ruby-identifier">raise</span> <span class="ruby-constant">ArgumentError</span>.<span class="ruby-identifier">new</span>(<span class="ruby-node">&quot;wrong number of arguments (#{argc} for #{arity}..*)&quot;</span>)
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- validate_argc-source -->
          
        </div>

        

        
      </div><!-- validate_argc-method -->

    
    </section><!-- public-class-method-details -->
  
     <section id="public-instance-5Buntitled-5D-method-details" class="method-section section">
      <h3 class="section-header">Public Instance Methods</h3>

    
      <div id="method-i-async" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">async</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Causes the chained method call to be performed asynchronously on the
object&#39;s thread. The delegated method will return a future in the
`:pending` state and the method call will have been scheduled on the
object&#39;s thread. The final disposition of the method call can be
obtained by inspecting the returned future.</p>

<p>@!macro [attach] async_thread_safety_warning</p>

<pre>@note The method call is guaranteed to be thread safe with respect to
  all other method calls against the same object that are called with
  either `async` or `await`. The mutable nature of Ruby references
  (and object orientation in general) prevent any other thread safety
  guarantees. Do NOT mix direct method calls with delegated method calls.
  Use *only* delegated method calls when sharing the object between threads.</pre>

<p>@return [Concurrent::IVar] the pending result of the asynchronous operation</p>

<p>@raise [NameError] the object does not respond to the requested method
@raise [ArgumentError] the given `args` do not match the arity of</p>

<pre>the requested method</pre>
          
          

          
          <div class="method-source-code" id="async-source">
            <pre><span class="ruby-comment"># File lib/concurrent/async.rb, line 408</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">async</span>
  <span class="ruby-ivar">@__async_delegator__</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- async-source -->
          
        </div>

        
        <div class="aliases">
          Also aliased as: <a href="Async.html#method-i-cast">cast</a>
        </div>
        

        
      </div><!-- async-method -->

    
      <div id="method-i-await" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">await</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Causes the chained method call to be performed synchronously on the current
thread. The delegated will return a future in either the `:fulfilled` or
`:rejected` state and the delegated method will have completed. The final
disposition of the delegated method can be obtained by inspecting the
returned future.</p>

<p>@!macro async_thread_safety_warning</p>

<p>@return [Concurrent::IVar] the completed result of the synchronous
operation</p>

<p>@raise [NameError] the object does not respond to the requested method
@raise [ArgumentError] the given `args` do not match the arity of the</p>

<pre>requested method</pre>
          
          

          
          <div class="method-source-code" id="await-source">
            <pre><span class="ruby-comment"># File lib/concurrent/async.rb, line 426</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">await</span>
  <span class="ruby-ivar">@__await_delegator__</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- await-source -->
          
        </div>

        
        <div class="aliases">
          Also aliased as: <a href="Async.html#method-i-call">call</a>
        </div>
        

        
      </div><!-- await-method -->

    
      <div id="method-i-call" class="method-detail method-alias">
        
        <div class="method-heading">
          <span class="method-name">call</span><span
            class="method-args">()</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
        </div>

        

        
        <div class="aliases">
          Alias for: <a href="Async.html#method-i-await">await</a>
        </div>
        
      </div><!-- call-method -->

    
      <div id="method-i-cast" class="method-detail method-alias">
        
        <div class="method-heading">
          <span class="method-name">cast</span><span
            class="method-args">()</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
        </div>

        

        
        <div class="aliases">
          Alias for: <a href="Async.html#method-i-async">async</a>
        </div>
        
      </div><!-- cast-method -->

    
      <div id="method-i-init_synchronization" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">init_synchronization</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Initialize the internal serializer and other stnchronization mechanisms.</p>

<p>@note This method <strong>must</strong> be called immediately upon object
construction.</p>

<pre>This is the only way thread-safe initialization can be guaranteed.</pre>

<p>@!visibility private</p>
          
          

          
          <div class="method-source-code" id="init_synchronization-source">
            <pre><span class="ruby-comment"># File lib/concurrent/async.rb, line 437</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">init_synchronization</span>
  <span class="ruby-keyword">return</span> <span class="ruby-keyword">self</span> <span class="ruby-keyword">if</span> <span class="ruby-ivar">@__async_initialized__</span>
  <span class="ruby-ivar">@__async_initialized__</span> = <span class="ruby-keyword">true</span>
  <span class="ruby-ivar">@__async_delegator__</span> = <span class="ruby-constant">AsyncDelegator</span>.<span class="ruby-identifier">new</span>(<span class="ruby-keyword">self</span>)
  <span class="ruby-ivar">@__await_delegator__</span> = <span class="ruby-constant">AwaitDelegator</span>.<span class="ruby-identifier">new</span>(<span class="ruby-ivar">@__async_delegator__</span>)
  <span class="ruby-keyword">self</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- init_synchronization-source -->
          
        </div>

        

        
      </div><!-- init_synchronization-method -->

    
    </section><!-- public-instance-method-details -->
  
  </section><!-- 5Buntitled-5D -->

</div><!-- documentation -->


<footer id="validator-badges">
  <p><a href="http://validator.w3.org/check/referer">[Validate]</a>
  <p>Generated by <a href="https://github.com/rdoc/rdoc">RDoc</a> 4.0.0.
  <p>Generated with the <a href="http://deveiate.org/projects/Darkfish-Rdoc/">Darkfish Rdoc Generator</a> 3.
</footer>

