<!DOCTYPE html>

<html>
<head>
<meta content="text/html; charset=UTF-8" http-equiv="Content-Type">

<title>class Concurrent::ReentrantReadWriteLock - concurrent-ruby-1.0.2 Documentation</title>

<link type="text/css" media="screen" href="../rdoc.css" rel="stylesheet">

<script type="text/javascript">
  var rdoc_rel_prefix = "../";
</script>

<script type="text/javascript" charset="utf-8" src="../js/jquery.js"></script>
<script type="text/javascript" charset="utf-8" src="../js/navigation.js"></script>
<script type="text/javascript" charset="utf-8" src="../js/search_index.js"></script>
<script type="text/javascript" charset="utf-8" src="../js/search.js"></script>
<script type="text/javascript" charset="utf-8" src="../js/searcher.js"></script>
<script type="text/javascript" charset="utf-8" src="../js/darkfish.js"></script>


<body id="top" class="class">
<nav id="metadata">
  <nav id="home-section" class="section">
  <h3 class="section-header">
    <a href="../index.html">Home</a>
    <a href="../table_of_contents.html#classes">Classes</a>
    <a href="../table_of_contents.html#methods">Methods</a>
  </h3>
</nav>


  <nav id="search-section" class="section project-section" class="initially-hidden">
  <form action="#" method="get" accept-charset="utf-8">
    <h3 class="section-header">
      <input type="text" name="search" placeholder="Search" id="search-field"
             title="Type to search, Up and Down to navigate, Enter to load">
    </h3>
  </form>

  <ul id="search-results" class="initially-hidden"></ul>
</nav>


  

  <div id="file-metadata">
    <nav id="file-list-section" class="section">
  <h3 class="section-header">Defined In</h3>
  <ul>
    <li>lib/concurrent/atomic/reentrant_read_write_lock.rb
  </ul>
</nav>

    
  </div>

  <div id="class-metadata">
    
    <nav id="parent-class-section" class="section">
  <h3 class="section-header">Parent</h3>
  
  <p class="link">Synchronization::Object
  
</nav>

    
    
    <!-- Method Quickref -->
<nav id="method-list-section" class="section">
  <h3 class="section-header">Methods</h3>

  <ul class="link-list">
    
    <li class="calls-super" ><a href="#method-c-new">::new</a>
    
    <li ><a href="#method-i-acquire_read_lock">#acquire_read_lock</a>
    
    <li ><a href="#method-i-acquire_write_lock">#acquire_write_lock</a>
    
    <li ><a href="#method-i-max_readers-3F">#max_readers?</a>
    
    <li ><a href="#method-i-max_writers-3F">#max_writers?</a>
    
    <li ><a href="#method-i-release_read_lock">#release_read_lock</a>
    
    <li ><a href="#method-i-release_write_lock">#release_write_lock</a>
    
    <li ><a href="#method-i-running_readers">#running_readers</a>
    
    <li ><a href="#method-i-running_readers-3F">#running_readers?</a>
    
    <li ><a href="#method-i-running_writer-3F">#running_writer?</a>
    
    <li ><a href="#method-i-try_read_lock">#try_read_lock</a>
    
    <li ><a href="#method-i-try_write_lock">#try_write_lock</a>
    
    <li ><a href="#method-i-waiting_or_running_writer-3F">#waiting_or_running_writer?</a>
    
    <li ><a href="#method-i-waiting_writers">#waiting_writers</a>
    
    <li ><a href="#method-i-with_read_lock">#with_read_lock</a>
    
    <li ><a href="#method-i-with_write_lock">#with_write_lock</a>
    
  </ul>
</nav>

  </div>

  <div id="project-metadata">
    <nav id="fileindex-section" class="section project-section">
  <h3 class="section-header">Pages</h3>

  <ul>
  
    <li class="file"><a href="../CHANGELOG_md.html">CHANGELOG</a>
  
    <li class="file"><a href="../LICENSE_txt.html">LICENSE</a>
  
    <li class="file"><a href="../README_md.html">README</a>
  
  </ul>
</nav>

    <nav id="classindex-section" class="section project-section">
  <h3 class="section-header">Class and Module Index</h3>

  <ul class="link-list">
  
    <li><a href="../Concurrent.html">Concurrent</a>
  
    <li><a href="../Concurrent/AbstractExchanger.html">Concurrent::AbstractExchanger</a>
  
    <li><a href="../Concurrent/AbstractExecutorService.html">Concurrent::AbstractExecutorService</a>
  
    <li><a href="../Concurrent/AbstractThreadLocalVar.html">Concurrent::AbstractThreadLocalVar</a>
  
    <li><a href="../Concurrent/Agent.html">Concurrent::Agent</a>
  
    <li><a href="../Concurrent/Agent/Error.html">Concurrent::Agent::Error</a>
  
    <li><a href="../Concurrent/Agent/ValidationError.html">Concurrent::Agent::ValidationError</a>
  
    <li><a href="../Concurrent/Array.html">Concurrent::Array</a>
  
    <li><a href="../Concurrent/Async.html">Concurrent::Async</a>
  
    <li><a href="../Concurrent/Async/AsyncDelegator.html">Concurrent::Async::AsyncDelegator</a>
  
    <li><a href="../Concurrent/Async/AwaitDelegator.html">Concurrent::Async::AwaitDelegator</a>
  
    <li><a href="../Concurrent/Async/ClassMethods.html">Concurrent::Async::ClassMethods</a>
  
    <li><a href="../Concurrent/AtExitImplementation.html">Concurrent::AtExitImplementation</a>
  
    <li><a href="../Concurrent/Atom.html">Concurrent::Atom</a>
  
    <li><a href="../Concurrent/AtomicBoolean.html">Concurrent::AtomicBoolean</a>
  
    <li><a href="../Concurrent/AtomicDirectUpdate.html">Concurrent::AtomicDirectUpdate</a>
  
    <li><a href="../Concurrent/AtomicFixnum.html">Concurrent::AtomicFixnum</a>
  
    <li><a href="../Concurrent/AtomicNumericCompareAndSetWrapper.html">Concurrent::AtomicNumericCompareAndSetWrapper</a>
  
    <li><a href="../Concurrent/AtomicReference.html">Concurrent::AtomicReference</a>
  
    <li><a href="../Concurrent/CAtomicReference.html">Concurrent::CAtomicReference</a>
  
    <li><a href="../Concurrent/CachedThreadPool.html">Concurrent::CachedThreadPool</a>
  
    <li><a href="../Concurrent/Collection.html">Concurrent::Collection</a>
  
    <li><a href="../Concurrent/Collection/AtomicReferenceMapBackend.html">Concurrent::Collection::AtomicReferenceMapBackend</a>
  
    <li><a href="../Concurrent/Collection/AtomicReferenceMapBackend/Node.html">Concurrent::Collection::AtomicReferenceMapBackend::Node</a>
  
    <li><a href="../Concurrent/Collection/AtomicReferenceMapBackend/Table.html">Concurrent::Collection::AtomicReferenceMapBackend::Table</a>
  
    <li><a href="../Concurrent/Collection/CopyOnNotifyObserverSet.html">Concurrent::Collection::CopyOnNotifyObserverSet</a>
  
    <li><a href="../Concurrent/Collection/CopyOnWriteObserverSet.html">Concurrent::Collection::CopyOnWriteObserverSet</a>
  
    <li><a href="../Concurrent/Collection/JavaNonConcurrentPriorityQueue.html">Concurrent::Collection::JavaNonConcurrentPriorityQueue</a>
  
    <li><a href="../Concurrent/Collection/MriMapBackend.html">Concurrent::Collection::MriMapBackend</a>
  
    <li><a href="../Concurrent/Collection/NonConcurrentMapBackend.html">Concurrent::Collection::NonConcurrentMapBackend</a>
  
    <li><a href="../Concurrent/Collection/NonConcurrentPriorityQueue.html">Concurrent::Collection::NonConcurrentPriorityQueue</a>
  
    <li><a href="../Concurrent/Collection/RubyNonConcurrentPriorityQueue.html">Concurrent::Collection::RubyNonConcurrentPriorityQueue</a>
  
    <li><a href="../Concurrent/Collection/SynchronizedMapBackend.html">Concurrent::Collection::SynchronizedMapBackend</a>
  
    <li><a href="../Concurrent/Concern.html">Concurrent::Concern</a>
  
    <li><a href="../Concurrent/Concern/Deprecation.html">Concurrent::Concern::Deprecation</a>
  
    <li><a href="../Concurrent/Concern/Dereferenceable.html">Concurrent::Concern::Dereferenceable</a>
  
    <li><a href="../Concurrent/Concern/Logging.html">Concurrent::Concern::Logging</a>
  
    <li><a href="../Concurrent/Concern/Obligation.html">Concurrent::Concern::Obligation</a>
  
    <li><a href="../Concurrent/Concern/Observable.html">Concurrent::Concern::Observable</a>
  
    <li><a href="../Concurrent/ConcurrentUpdateError.html">Concurrent::ConcurrentUpdateError</a>
  
    <li><a href="../Concurrent/CountDownLatch.html">Concurrent::CountDownLatch</a>
  
    <li><a href="../Concurrent/CyclicBarrier.html">Concurrent::CyclicBarrier</a>
  
    <li><a href="../Concurrent/Delay.html">Concurrent::Delay</a>
  
    <li><a href="../Concurrent/DependencyCounter.html">Concurrent::DependencyCounter</a>
  
    <li><a href="../Concurrent/Edge.html">Concurrent::Edge</a>
  
    <li><a href="../Concurrent/Event.html">Concurrent::Event</a>
  
    <li><a href="../Concurrent/Exchanger.html">Concurrent::Exchanger</a>
  
    <li><a href="../Concurrent/ExecutorService.html">Concurrent::ExecutorService</a>
  
    <li><a href="../Concurrent/FixedThreadPool.html">Concurrent::FixedThreadPool</a>
  
    <li><a href="../Concurrent/Future.html">Concurrent::Future</a>
  
    <li><a href="../Concurrent/Hash.html">Concurrent::Hash</a>
  
    <li><a href="../Concurrent/IVar.html">Concurrent::IVar</a>
  
    <li><a href="../Concurrent/ImmediateExecutor.html">Concurrent::ImmediateExecutor</a>
  
    <li><a href="../Concurrent/ImmutableStruct.html">Concurrent::ImmutableStruct</a>
  
    <li><a href="../Concurrent/IndirectImmediateExecutor.html">Concurrent::IndirectImmediateExecutor</a>
  
    <li><a href="../Concurrent/JavaAtomicReference.html">Concurrent::JavaAtomicReference</a>
  
    <li><a href="../Concurrent/JavaCountDownLatch.html">Concurrent::JavaCountDownLatch</a>
  
    <li><a href="../Concurrent/JavaExchanger.html">Concurrent::JavaExchanger</a>
  
    <li><a href="../Concurrent/JavaExecutorService.html">Concurrent::JavaExecutorService</a>
  
    <li><a href="../Concurrent/JavaExecutorService/Job.html">Concurrent::JavaExecutorService::Job</a>
  
    <li><a href="../Concurrent/JavaSingleThreadExecutor.html">Concurrent::JavaSingleThreadExecutor</a>
  
    <li><a href="../Concurrent/JavaThreadLocalVar.html">Concurrent::JavaThreadLocalVar</a>
  
    <li><a href="../Concurrent/JavaThreadPoolExecutor.html">Concurrent::JavaThreadPoolExecutor</a>
  
    <li><a href="../Concurrent/LazyRegister.html">Concurrent::LazyRegister</a>
  
    <li><a href="../Concurrent/MVar.html">Concurrent::MVar</a>
  
    <li><a href="../Concurrent/Map.html">Concurrent::Map</a>
  
    <li><a href="../Concurrent/Maybe.html">Concurrent::Maybe</a>
  
    <li><a href="../Concurrent/MutableStruct.html">Concurrent::MutableStruct</a>
  
    <li><a href="../Concurrent/MutexAtomicBoolean.html">Concurrent::MutexAtomicBoolean</a>
  
    <li><a href="../Concurrent/MutexAtomicFixnum.html">Concurrent::MutexAtomicFixnum</a>
  
    <li><a href="../Concurrent/MutexAtomicReference.html">Concurrent::MutexAtomicReference</a>
  
    <li><a href="../Concurrent/MutexCountDownLatch.html">Concurrent::MutexCountDownLatch</a>
  
    <li><a href="../Concurrent/MutexSemaphore.html">Concurrent::MutexSemaphore</a>
  
    <li><a href="../Concurrent/Options.html">Concurrent::Options</a>
  
    <li><a href="../Concurrent/Process.html">Concurrent::Process</a>
  
    <li><a href="../Concurrent/Promise.html">Concurrent::Promise</a>
  
    <li><a href="../Concurrent/RbxAtomicReference.html">Concurrent::RbxAtomicReference</a>
  
    <li><a href="../Concurrent/ReadWriteLock.html">Concurrent::ReadWriteLock</a>
  
    <li><a href="../Concurrent/ReentrantReadWriteLock.html">Concurrent::ReentrantReadWriteLock</a>
  
    <li><a href="../Concurrent/RubyExchanger.html">Concurrent::RubyExchanger</a>
  
    <li><a href="../Concurrent/RubyExchanger/Node.html">Concurrent::RubyExchanger::Node</a>
  
    <li><a href="../Concurrent/RubyExecutorService.html">Concurrent::RubyExecutorService</a>
  
    <li><a href="../Concurrent/RubySingleThreadExecutor.html">Concurrent::RubySingleThreadExecutor</a>
  
    <li><a href="../Concurrent/RubyThreadLocalVar.html">Concurrent::RubyThreadLocalVar</a>
  
    <li><a href="../Concurrent/RubyThreadPoolExecutor.html">Concurrent::RubyThreadPoolExecutor</a>
  
    <li><a href="../Concurrent/RubyThreadPoolExecutor/Worker.html">Concurrent::RubyThreadPoolExecutor::Worker</a>
  
    <li><a href="../Concurrent/SafeTaskExecutor.html">Concurrent::SafeTaskExecutor</a>
  
    <li><a href="../Concurrent/ScheduledTask.html">Concurrent::ScheduledTask</a>
  
    <li><a href="../Concurrent/Semaphore.html">Concurrent::Semaphore</a>
  
    <li><a href="../Concurrent/SerialExecutorService.html">Concurrent::SerialExecutorService</a>
  
    <li><a href="../Concurrent/SerializedExecution.html">Concurrent::SerializedExecution</a>
  
    <li><a href="../Concurrent/SerializedExecutionDelegator.html">Concurrent::SerializedExecutionDelegator</a>
  
    <li><a href="../Concurrent/SettableStruct.html">Concurrent::SettableStruct</a>
  
    <li><a href="../Concurrent/SimpleExecutorService.html">Concurrent::SimpleExecutorService</a>
  
    <li><a href="../Concurrent/SingleThreadExecutor.html">Concurrent::SingleThreadExecutor</a>
  
    <li><a href="../Concurrent/Synchronization.html">Concurrent::Synchronization</a>
  
    <li><a href="../Concurrent/Synchronization/AbstractLockableObject.html">Concurrent::Synchronization::AbstractLockableObject</a>
  
    <li><a href="../Concurrent/Synchronization/AbstractObject.html">Concurrent::Synchronization::AbstractObject</a>
  
    <li><a href="../Concurrent/Synchronization/AbstractStruct.html">Concurrent::Synchronization::AbstractStruct</a>
  
    <li><a href="../Concurrent/Synchronization/Condition.html">Concurrent::Synchronization::Condition</a>
  
    <li><a href="../Concurrent/Synchronization/JRubyAttrVolatile.html">Concurrent::Synchronization::JRubyAttrVolatile</a>
  
    <li><a href="../Concurrent/Synchronization/JRubyAttrVolatile/ClassMethods.html">Concurrent::Synchronization::JRubyAttrVolatile::ClassMethods</a>
  
    <li><a href="../Concurrent/Synchronization/JRubyLockableObject.html">Concurrent::Synchronization::JRubyLockableObject</a>
  
    <li><a href="../Concurrent/Synchronization/JRubyObject.html">Concurrent::Synchronization::JRubyObject</a>
  
    <li><a href="../Concurrent/Synchronization/Lock.html">Concurrent::Synchronization::Lock</a>
  
    <li><a href="../Concurrent/Synchronization/LockableObject.html">Concurrent::Synchronization::LockableObject</a>
  
    <li><a href="../Concurrent/Synchronization/MriAttrVolatile.html">Concurrent::Synchronization::MriAttrVolatile</a>
  
    <li><a href="../Concurrent/Synchronization/MriAttrVolatile/ClassMethods.html">Concurrent::Synchronization::MriAttrVolatile::ClassMethods</a>
  
    <li><a href="../Concurrent/Synchronization/MriLockableObject.html">Concurrent::Synchronization::MriLockableObject</a>
  
    <li><a href="../Concurrent/Synchronization/MriMonitorLockableObject.html">Concurrent::Synchronization::MriMonitorLockableObject</a>
  
    <li><a href="../Concurrent/Synchronization/MriMutexLockableObject.html">Concurrent::Synchronization::MriMutexLockableObject</a>
  
    <li><a href="../Concurrent/Synchronization/MriObject.html">Concurrent::Synchronization::MriObject</a>
  
    <li><a href="../Concurrent/Synchronization/Object.html">Concurrent::Synchronization::Object</a>
  
    <li><a href="../Concurrent/Synchronization/RbxAttrVolatile.html">Concurrent::Synchronization::RbxAttrVolatile</a>
  
    <li><a href="../Concurrent/Synchronization/RbxAttrVolatile/ClassMethods.html">Concurrent::Synchronization::RbxAttrVolatile::ClassMethods</a>
  
    <li><a href="../Concurrent/Synchronization/RbxLockableObject.html">Concurrent::Synchronization::RbxLockableObject</a>
  
    <li><a href="../Concurrent/Synchronization/RbxObject.html">Concurrent::Synchronization::RbxObject</a>
  
    <li><a href="../Concurrent/Synchronization/TruffleAttrVolatile.html">Concurrent::Synchronization::TruffleAttrVolatile</a>
  
    <li><a href="../Concurrent/Synchronization/TruffleAttrVolatile/ClassMethods.html">Concurrent::Synchronization::TruffleAttrVolatile::ClassMethods</a>
  
    <li><a href="../Concurrent/Synchronization/TruffleLockableObject.html">Concurrent::Synchronization::TruffleLockableObject</a>
  
    <li><a href="../Concurrent/Synchronization/TruffleObject.html">Concurrent::Synchronization::TruffleObject</a>
  
    <li><a href="../Concurrent/SynchronizedDelegator.html">Concurrent::SynchronizedDelegator</a>
  
    <li><a href="../Concurrent/TVar.html">Concurrent::TVar</a>
  
    <li><a href="../Concurrent/ThreadLocalVar.html">Concurrent::ThreadLocalVar</a>
  
    <li><a href="../Concurrent/ThreadPoolExecutor.html">Concurrent::ThreadPoolExecutor</a>
  
    <li><a href="../Concurrent/ThreadSafe.html">Concurrent::ThreadSafe</a>
  
    <li><a href="../Concurrent/ThreadSafe/Util.html">Concurrent::ThreadSafe::Util</a>
  
    <li><a href="../Concurrent/ThreadSafe/Util/Adder.html">Concurrent::ThreadSafe::Util::Adder</a>
  
    <li><a href="../Concurrent/ThreadSafe/Util/CheapLockable.html">Concurrent::ThreadSafe::Util::CheapLockable</a>
  
    <li><a href="../Concurrent/ThreadSafe/Util/PowerOfTwoTuple.html">Concurrent::ThreadSafe::Util::PowerOfTwoTuple</a>
  
    <li><a href="../Concurrent/ThreadSafe/Util/Striped64.html">Concurrent::ThreadSafe::Util::Striped64</a>
  
    <li><a href="../Concurrent/ThreadSafe/Util/Striped64/Cell.html">Concurrent::ThreadSafe::Util::Striped64::Cell</a>
  
    <li><a href="../Concurrent/ThreadSafe/Util/Volatile.html">Concurrent::ThreadSafe::Util::Volatile</a>
  
    <li><a href="../Concurrent/ThreadSafe/Util/XorShiftRandom.html">Concurrent::ThreadSafe::Util::XorShiftRandom</a>
  
    <li><a href="../Concurrent/TimerSet.html">Concurrent::TimerSet</a>
  
    <li><a href="../Concurrent/TimerTask.html">Concurrent::TimerTask</a>
  
    <li><a href="../Concurrent/Transaction.html">Concurrent::Transaction</a>
  
    <li><a href="../Concurrent/Tuple.html">Concurrent::Tuple</a>
  
    <li><a href="../Concurrent/Utility.html">Concurrent::Utility</a>
  
    <li><a href="../Concurrent/Utility/EngineDetector.html">Concurrent::Utility::EngineDetector</a>
  
    <li><a href="../Concurrent/Utility/NativeExtensionLoader.html">Concurrent::Utility::NativeExtensionLoader</a>
  
    <li><a href="../Concurrent/Utility/ProcessorCounter.html">Concurrent::Utility::ProcessorCounter</a>
  
  </ul>
</nav>

  </div>
</nav>

<div id="documentation">
  <h1 class="class">class Concurrent::ReentrantReadWriteLock</h1>

  <div id="description" class="description">
    
<p>Re-entrant read-write lock implementation</p>

<p>Allows any number of concurrent readers, but only one concurrent writer
(And while the “write” lock is taken, no read locks can be obtained either.
Hence, the write lock can also be called an “exclusive” lock.)</p>

<p>If another thread has taken a read lock, any thread which wants a write
lock will block until all the readers release their locks. However, once a
thread starts waiting to obtain a write lock, any additional readers that
come along will also wait (so writers are not starved).</p>

<p>A thread can acquire both a read and write lock at the same time. A thread
can also acquire a read lock OR a write lock more than once. Only when the
read (or write) lock is released as many times as it was acquired, will the
thread actually let it go, allowing other threads which might have been
waiting to proceed.</p>

<p>If both read and write locks are acquired by the same thread, it is not
strictly necessary to release them in the same order they were acquired. In
other words, the following code is legal:</p>

<p>@example</p>

<pre>lock = Concurrent::ReentrantReadWriteLock.new
lock.acquire_write_lock
lock.acquire_read_lock
lock.release_write_lock
# At this point, the current thread is holding only a read lock, not a write
# lock. So other threads can take read locks, but not a write lock.
lock.release_read_lock
# Now the current thread is not holding either a read or write lock, so
# another thread could potentially acquire a write lock.</pre>

<p>This implementation was inspired by
`java.util.concurrent.ReentrantReadWriteLock`.</p>

<p>@example</p>

<pre>lock = Concurrent::ReentrantReadWriteLock.new
lock.with_read_lock  { data.retrieve }
lock.with_write_lock { data.modify! }</pre>

<p>@see <a
href="http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/locks/ReentrantReadWriteLock.html">docs.oracle.com/javase/7/docs/api/java/util/concurrent/locks/ReentrantReadWriteLock.html</a>
java.util.concurrent.ReentrantReadWriteLock</p>

  </div><!-- description -->

  
  
  
  <section id="5Buntitled-5D" class="documentation-section">
    

    

    
    <!-- Constants -->
    <section id="constants-list" class="section">
      <h3 class="section-header">Constants</h3>
      <dl>
      
        <dt id="MAX_READERS">MAX_READERS
        
        <dd class="description"><p>@!visibility private</p>
        
      
        <dt id="MAX_WRITERS">MAX_WRITERS
        
        <dd class="description"><p>@!visibility private</p>
        
      
        <dt id="READER_BITS">READER_BITS
        
        <dd class="description"><p>@!visibility private</p>
        
      
        <dt id="READ_LOCK_MASK">READ_LOCK_MASK
        
        <dd class="description"><p>@!visibility private</p>
        
      
        <dt id="RUNNING_WRITER">RUNNING_WRITER
        
        <dd class="description"><p>@!visibility private</p>
        
      
        <dt id="WAITING_WRITER">WAITING_WRITER
        
        <dd class="description"><p>Used with @Counter: @!visibility private</p>
        
      
        <dt id="WRITER_BITS">WRITER_BITS
        
        <dd class="description"><p>@!visibility private</p>
        
      
        <dt id="WRITE_LOCK_HELD">WRITE_LOCK_HELD
        
        <dd class="description"><p>Used with @HeldCount: @!visibility private</p>
        
      
        <dt id="WRITE_LOCK_MASK">WRITE_LOCK_MASK
        
        <dd class="description"><p>@!visibility private</p>
        
      
      </dl>
    </section>
    

    

    <!-- Methods -->
    
     <section id="public-class-5Buntitled-5D-method-details" class="method-section section">
      <h3 class="section-header">Public Class Methods</h3>

    
      <div id="method-c-new" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">new</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Create a new `ReentrantReadWriteLock` in the unlocked state.</p>
          
          
            <div class="method-calls-super">
              Calls superclass method
              
            </div>
          

          
          <div class="method-source-code" id="new-source">
            <pre><span class="ruby-comment"># File lib/concurrent/atomic/reentrant_read_write_lock.rb, line 105</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">initialize</span>
  <span class="ruby-keyword">super</span>()
  <span class="ruby-ivar">@Counter</span>    = <span class="ruby-constant">AtomicFixnum</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">0</span>)       <span class="ruby-comment"># single integer which represents lock state</span>
  <span class="ruby-ivar">@ReadQueue</span>  = <span class="ruby-constant">Synchronization</span><span class="ruby-operator">::</span><span class="ruby-constant">Lock</span>.<span class="ruby-identifier">new</span> <span class="ruby-comment"># used to queue waiting readers</span>
  <span class="ruby-ivar">@WriteQueue</span> = <span class="ruby-constant">Synchronization</span><span class="ruby-operator">::</span><span class="ruby-constant">Lock</span>.<span class="ruby-identifier">new</span> <span class="ruby-comment"># used to queue waiting writers</span>
  <span class="ruby-ivar">@HeldCount</span>  = <span class="ruby-constant">ThreadLocalVar</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">0</span>)     <span class="ruby-comment"># indicates # of R &amp; W locks held by this thread</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- new-source -->
          
        </div>

        

        
      </div><!-- new-method -->

    
    </section><!-- public-class-method-details -->
  
     <section id="public-instance-5Buntitled-5D-method-details" class="method-section section">
      <h3 class="section-header">Public Instance Methods</h3>

    
      <div id="method-i-acquire_read_lock" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">acquire_read_lock</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Acquire a read lock. If a write lock is held by another thread, will block
until it is released.</p>

<p>@return [Boolean] true if the lock is successfully acquired</p>

<p>@raise [Concurrent::ResourceLimitError] if the maximum number of readers</p>

<pre>is exceeded.</pre>
          
          

          
          <div class="method-source-code" id="acquire_read_lock-source">
            <pre><span class="ruby-comment"># File lib/concurrent/atomic/reentrant_read_write_lock.rb, line 158</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">acquire_read_lock</span>
  <span class="ruby-keyword">if</span> (<span class="ruby-identifier">held</span> = <span class="ruby-ivar">@HeldCount</span>.<span class="ruby-identifier">value</span>) <span class="ruby-operator">&gt;</span> <span class="ruby-value">0</span>
    <span class="ruby-comment"># If we already have a lock, there&#39;s no need to wait</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">held</span> <span class="ruby-operator">&amp;</span> <span class="ruby-constant">READ_LOCK_MASK</span> <span class="ruby-operator">==</span> <span class="ruby-value">0</span>
      <span class="ruby-comment"># But we do need to update the counter, if we were holding a write</span>
      <span class="ruby-comment">#   lock but not a read lock</span>
      <span class="ruby-ivar">@Counter</span>.<span class="ruby-identifier">update</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">c</span><span class="ruby-operator">|</span> <span class="ruby-identifier">c</span> <span class="ruby-operator">+</span> <span class="ruby-value">1</span> }
    <span class="ruby-keyword">end</span>
    <span class="ruby-ivar">@HeldCount</span>.<span class="ruby-identifier">value</span> = <span class="ruby-identifier">held</span> <span class="ruby-operator">+</span> <span class="ruby-value">1</span>
    <span class="ruby-keyword">return</span> <span class="ruby-keyword">true</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-keyword">while</span> <span class="ruby-keyword">true</span>
    <span class="ruby-identifier">c</span> = <span class="ruby-ivar">@Counter</span>.<span class="ruby-identifier">value</span>
    <span class="ruby-identifier">raise</span> <span class="ruby-constant">ResourceLimitError</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&#39;Too many reader threads&#39;</span>) <span class="ruby-keyword">if</span> <span class="ruby-identifier">max_readers?</span>(<span class="ruby-identifier">c</span>)

    <span class="ruby-comment"># If a writer is waiting OR running when we first queue up, we need to wait</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">waiting_or_running_writer?</span>(<span class="ruby-identifier">c</span>)
      <span class="ruby-comment"># Before going to sleep, check again with the ReadQueue mutex held</span>
      <span class="ruby-ivar">@ReadQueue</span>.<span class="ruby-identifier">synchronize</span> <span class="ruby-keyword">do</span>
        <span class="ruby-ivar">@ReadQueue</span>.<span class="ruby-identifier">ns_wait</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">waiting_or_running_writer?</span>
      <span class="ruby-keyword">end</span>
      <span class="ruby-comment"># Note: the above &#39;synchronize&#39; block could have used #wait_until,</span>
      <span class="ruby-comment">#   but that waits repeatedly in a loop, checking the wait condition</span>
      <span class="ruby-comment">#   each time it wakes up (to protect against spurious wakeups)</span>
      <span class="ruby-comment"># But we are already in a loop, which is only broken when we successfully</span>
      <span class="ruby-comment">#   acquire the lock! So we don&#39;t care about spurious wakeups, and would</span>
      <span class="ruby-comment">#   rather not pay the extra overhead of using #wait_until</span>

      <span class="ruby-comment"># After a reader has waited once, they are allowed to &quot;barge&quot; ahead of waiting writers</span>
      <span class="ruby-comment"># But if a writer is *running*, the reader still needs to wait (naturally)</span>
      <span class="ruby-keyword">while</span> <span class="ruby-keyword">true</span>
        <span class="ruby-identifier">c</span> = <span class="ruby-ivar">@Counter</span>.<span class="ruby-identifier">value</span>
        <span class="ruby-keyword">if</span> <span class="ruby-identifier">running_writer?</span>(<span class="ruby-identifier">c</span>)
          <span class="ruby-ivar">@ReadQueue</span>.<span class="ruby-identifier">synchronize</span> <span class="ruby-keyword">do</span>
            <span class="ruby-ivar">@ReadQueue</span>.<span class="ruby-identifier">ns_wait</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">running_writer?</span>
          <span class="ruby-keyword">end</span>
        <span class="ruby-keyword">elsif</span> <span class="ruby-ivar">@Counter</span>.<span class="ruby-identifier">compare_and_set</span>(<span class="ruby-identifier">c</span>, <span class="ruby-identifier">c</span><span class="ruby-operator">+</span><span class="ruby-value">1</span>)
          <span class="ruby-ivar">@HeldCount</span>.<span class="ruby-identifier">value</span> = <span class="ruby-identifier">held</span> <span class="ruby-operator">+</span> <span class="ruby-value">1</span>
          <span class="ruby-keyword">return</span> <span class="ruby-keyword">true</span>
        <span class="ruby-keyword">end</span>
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">elsif</span> <span class="ruby-ivar">@Counter</span>.<span class="ruby-identifier">compare_and_set</span>(<span class="ruby-identifier">c</span>, <span class="ruby-identifier">c</span><span class="ruby-operator">+</span><span class="ruby-value">1</span>)
      <span class="ruby-ivar">@HeldCount</span>.<span class="ruby-identifier">value</span> = <span class="ruby-identifier">held</span> <span class="ruby-operator">+</span> <span class="ruby-value">1</span>
      <span class="ruby-keyword">return</span> <span class="ruby-keyword">true</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- acquire_read_lock-source -->
          
        </div>

        

        
      </div><!-- acquire_read_lock-method -->

    
      <div id="method-i-acquire_write_lock" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">acquire_write_lock</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Acquire a write lock. Will block and wait for all active readers and
writers.</p>

<p>@return [Boolean] true if the lock is successfully acquired</p>

<p>@raise [Concurrent::ResourceLimitError] if the maximum number of writers</p>

<pre>is exceeded.</pre>
          
          

          
          <div class="method-source-code" id="acquire_write_lock-source">
            <pre><span class="ruby-comment"># File lib/concurrent/atomic/reentrant_read_write_lock.rb, line 253</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">acquire_write_lock</span>
  <span class="ruby-keyword">if</span> (<span class="ruby-identifier">held</span> = <span class="ruby-ivar">@HeldCount</span>.<span class="ruby-identifier">value</span>) <span class="ruby-operator">&gt;=</span> <span class="ruby-constant">WRITE_LOCK_HELD</span>
    <span class="ruby-comment"># if we already have a write (exclusive) lock, there&#39;s no need to wait</span>
    <span class="ruby-ivar">@HeldCount</span>.<span class="ruby-identifier">value</span> = <span class="ruby-identifier">held</span> <span class="ruby-operator">+</span> <span class="ruby-constant">WRITE_LOCK_HELD</span>
    <span class="ruby-keyword">return</span> <span class="ruby-keyword">true</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-keyword">while</span> <span class="ruby-keyword">true</span>
    <span class="ruby-identifier">c</span> = <span class="ruby-ivar">@Counter</span>.<span class="ruby-identifier">value</span>
    <span class="ruby-identifier">raise</span> <span class="ruby-constant">ResourceLimitError</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&#39;Too many writer threads&#39;</span>) <span class="ruby-keyword">if</span> <span class="ruby-identifier">max_writers?</span>(<span class="ruby-identifier">c</span>)

    <span class="ruby-comment"># To go ahead and take the lock without waiting, there must be no writer</span>
    <span class="ruby-comment">#   running right now, AND no writers who came before us still waiting to</span>
    <span class="ruby-comment">#   acquire the lock</span>
    <span class="ruby-comment"># Additionally, if any read locks have been taken, we must hold all of them</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">c</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">held</span>
      <span class="ruby-comment"># If we successfully swap the RUNNING_WRITER bit on, then we can go ahead</span>
      <span class="ruby-keyword">if</span> <span class="ruby-ivar">@Counter</span>.<span class="ruby-identifier">compare_and_set</span>(<span class="ruby-identifier">c</span>, <span class="ruby-identifier">c</span><span class="ruby-operator">+</span><span class="ruby-constant">RUNNING_WRITER</span>)
        <span class="ruby-ivar">@HeldCount</span>.<span class="ruby-identifier">value</span> = <span class="ruby-identifier">held</span> <span class="ruby-operator">+</span> <span class="ruby-constant">WRITE_LOCK_HELD</span>
        <span class="ruby-keyword">return</span> <span class="ruby-keyword">true</span>
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">elsif</span> <span class="ruby-ivar">@Counter</span>.<span class="ruby-identifier">compare_and_set</span>(<span class="ruby-identifier">c</span>, <span class="ruby-identifier">c</span><span class="ruby-operator">+</span><span class="ruby-constant">WAITING_WRITER</span>)
      <span class="ruby-keyword">while</span> <span class="ruby-keyword">true</span>
        <span class="ruby-comment"># Now we have successfully incremented, so no more readers will be able to increment</span>
        <span class="ruby-comment">#   (they will wait instead)</span>
        <span class="ruby-comment"># However, readers OR writers could decrement right here</span>
        <span class="ruby-ivar">@WriteQueue</span>.<span class="ruby-identifier">synchronize</span> <span class="ruby-keyword">do</span>
          <span class="ruby-comment"># So we have to do another check inside the synchronized section</span>
          <span class="ruby-comment"># If a writer OR another reader is running, then go to sleep</span>
          <span class="ruby-identifier">c</span> = <span class="ruby-ivar">@Counter</span>.<span class="ruby-identifier">value</span>
          <span class="ruby-ivar">@WriteQueue</span>.<span class="ruby-identifier">ns_wait</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">running_writer?</span>(<span class="ruby-identifier">c</span>) <span class="ruby-operator">||</span> <span class="ruby-identifier">running_readers</span>(<span class="ruby-identifier">c</span>) <span class="ruby-operator">!=</span> <span class="ruby-identifier">held</span>
        <span class="ruby-keyword">end</span>
        <span class="ruby-comment"># Note: if you are thinking of replacing the above &#39;synchronize&#39; block</span>
        <span class="ruby-comment"># with #wait_until, read the comment in #acquire_read_lock first!</span>

        <span class="ruby-comment"># We just came out of a wait</span>
        <span class="ruby-comment"># If we successfully turn the RUNNING_WRITER bit on with an atomic swap,</span>
        <span class="ruby-comment">#   then we are OK to stop waiting and go ahead</span>
        <span class="ruby-comment"># Otherwise go back and wait again</span>
        <span class="ruby-identifier">c</span> = <span class="ruby-ivar">@Counter</span>.<span class="ruby-identifier">value</span>
        <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">running_writer?</span>(<span class="ruby-identifier">c</span>) <span class="ruby-operator">&amp;&amp;</span>
           <span class="ruby-identifier">running_readers</span>(<span class="ruby-identifier">c</span>) <span class="ruby-operator">==</span> <span class="ruby-identifier">held</span> <span class="ruby-operator">&amp;&amp;</span>
           <span class="ruby-ivar">@Counter</span>.<span class="ruby-identifier">compare_and_set</span>(<span class="ruby-identifier">c</span>, <span class="ruby-identifier">c</span><span class="ruby-operator">+</span><span class="ruby-constant">RUNNING_WRITER</span><span class="ruby-operator">-</span><span class="ruby-constant">WAITING_WRITER</span>)
          <span class="ruby-ivar">@HeldCount</span>.<span class="ruby-identifier">value</span> = <span class="ruby-identifier">held</span> <span class="ruby-operator">+</span> <span class="ruby-constant">WRITE_LOCK_HELD</span>
          <span class="ruby-keyword">return</span> <span class="ruby-keyword">true</span>
        <span class="ruby-keyword">end</span>
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- acquire_write_lock-source -->
          
        </div>

        

        
      </div><!-- acquire_write_lock-method -->

    
      <div id="method-i-release_read_lock" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">release_read_lock</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Release a previously acquired read lock.</p>

<p>@return [Boolean] true if the lock is successfully released</p>
          
          

          
          <div class="method-source-code" id="release_read_lock-source">
            <pre><span class="ruby-comment"># File lib/concurrent/atomic/reentrant_read_write_lock.rb, line 232</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">release_read_lock</span>
  <span class="ruby-identifier">held</span> = <span class="ruby-ivar">@HeldCount</span>.<span class="ruby-identifier">value</span> = <span class="ruby-ivar">@HeldCount</span>.<span class="ruby-identifier">value</span> <span class="ruby-operator">-</span> <span class="ruby-value">1</span>
  <span class="ruby-identifier">rlocks_held</span> = <span class="ruby-identifier">held</span> <span class="ruby-operator">&amp;</span> <span class="ruby-constant">READ_LOCK_MASK</span>
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">rlocks_held</span> <span class="ruby-operator">==</span> <span class="ruby-value">0</span>
    <span class="ruby-identifier">c</span> = <span class="ruby-ivar">@Counter</span>.<span class="ruby-identifier">update</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">counter</span><span class="ruby-operator">|</span> <span class="ruby-identifier">counter</span> <span class="ruby-operator">-</span> <span class="ruby-value">1</span> }
    <span class="ruby-comment"># If one or more writers were waiting, and we were the last reader, wake a writer up</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">waiting_or_running_writer?</span>(<span class="ruby-identifier">c</span>) <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">running_readers</span>(<span class="ruby-identifier">c</span>) <span class="ruby-operator">==</span> <span class="ruby-value">0</span>
      <span class="ruby-ivar">@WriteQueue</span>.<span class="ruby-identifier">signal</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">rlocks_held</span> <span class="ruby-operator">==</span> <span class="ruby-constant">READ_LOCK_MASK</span>
    <span class="ruby-identifier">raise</span> <span class="ruby-constant">IllegalOperationError</span>, <span class="ruby-string">&quot;Cannot release a read lock which is not held&quot;</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">true</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- release_read_lock-source -->
          
        </div>

        

        
      </div><!-- release_read_lock-method -->

    
      <div id="method-i-release_write_lock" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">release_write_lock</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Release a previously acquired write lock.</p>

<p>@return [Boolean] true if the lock is successfully released</p>
          
          

          
          <div class="method-source-code" id="release_write_lock-source">
            <pre><span class="ruby-comment"># File lib/concurrent/atomic/reentrant_read_write_lock.rb, line 327</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">release_write_lock</span>
  <span class="ruby-identifier">held</span> = <span class="ruby-ivar">@HeldCount</span>.<span class="ruby-identifier">value</span> = <span class="ruby-ivar">@HeldCount</span>.<span class="ruby-identifier">value</span> <span class="ruby-operator">-</span> <span class="ruby-constant">WRITE_LOCK_HELD</span>
  <span class="ruby-identifier">wlocks_held</span> = <span class="ruby-identifier">held</span> <span class="ruby-operator">&amp;</span> <span class="ruby-constant">WRITE_LOCK_MASK</span>
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">wlocks_held</span> <span class="ruby-operator">==</span> <span class="ruby-value">0</span>
    <span class="ruby-identifier">c</span> = <span class="ruby-ivar">@Counter</span>.<span class="ruby-identifier">update</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">counter</span><span class="ruby-operator">|</span> <span class="ruby-identifier">counter</span> <span class="ruby-operator">-</span> <span class="ruby-constant">RUNNING_WRITER</span> }
    <span class="ruby-ivar">@ReadQueue</span>.<span class="ruby-identifier">broadcast</span>
    <span class="ruby-ivar">@WriteQueue</span>.<span class="ruby-identifier">signal</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">waiting_writers</span>(<span class="ruby-identifier">c</span>) <span class="ruby-operator">&gt;</span> <span class="ruby-value">0</span>
  <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">wlocks_held</span> <span class="ruby-operator">==</span> <span class="ruby-constant">WRITE_LOCK_MASK</span>
    <span class="ruby-identifier">raise</span> <span class="ruby-constant">IllegalOperationError</span>, <span class="ruby-string">&quot;Cannot release a write lock which is not held&quot;</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">true</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- release_write_lock-source -->
          
        </div>

        

        
      </div><!-- release_write_lock-method -->

    
      <div id="method-i-try_read_lock" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">try_read_lock</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Try to acquire a read lock and return true if we succeed. If it cannot be
acquired immediately, return false.</p>

<p>@return [Boolean] true if the lock is successfully acquired</p>
          
          

          
          <div class="method-source-code" id="try_read_lock-source">
            <pre><span class="ruby-comment"># File lib/concurrent/atomic/reentrant_read_write_lock.rb, line 211</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">try_read_lock</span>
  <span class="ruby-keyword">if</span> (<span class="ruby-identifier">held</span> = <span class="ruby-ivar">@HeldCount</span>.<span class="ruby-identifier">value</span>) <span class="ruby-operator">&gt;</span> <span class="ruby-value">0</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">held</span> <span class="ruby-operator">&amp;</span> <span class="ruby-constant">READ_LOCK_MASK</span> <span class="ruby-operator">==</span> <span class="ruby-value">0</span>
      <span class="ruby-comment"># If we hold a write lock, but not a read lock...</span>
      <span class="ruby-ivar">@Counter</span>.<span class="ruby-identifier">update</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">c</span><span class="ruby-operator">|</span> <span class="ruby-identifier">c</span> <span class="ruby-operator">+</span> <span class="ruby-value">1</span> }
    <span class="ruby-keyword">end</span>
    <span class="ruby-ivar">@HeldCount</span>.<span class="ruby-identifier">value</span> = <span class="ruby-identifier">held</span> <span class="ruby-operator">+</span> <span class="ruby-value">1</span>
    <span class="ruby-keyword">return</span> <span class="ruby-keyword">true</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">c</span> = <span class="ruby-ivar">@Counter</span>.<span class="ruby-identifier">value</span>
    <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">waiting_or_running_writer?</span>(<span class="ruby-identifier">c</span>) <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-ivar">@Counter</span>.<span class="ruby-identifier">compare_and_set</span>(<span class="ruby-identifier">c</span>, <span class="ruby-identifier">c</span><span class="ruby-operator">+</span><span class="ruby-value">1</span>)
      <span class="ruby-ivar">@HeldCount</span>.<span class="ruby-identifier">value</span> = <span class="ruby-identifier">held</span> <span class="ruby-operator">+</span> <span class="ruby-value">1</span>
      <span class="ruby-keyword">return</span> <span class="ruby-keyword">true</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">false</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- try_read_lock-source -->
          
        </div>

        

        
      </div><!-- try_read_lock-method -->

    
      <div id="method-i-try_write_lock" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">try_write_lock</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Try to acquire a write lock and return true if we succeed. If it cannot be
acquired immediately, return false.</p>

<p>@return [Boolean] true if the lock is successfully acquired</p>
          
          

          
          <div class="method-source-code" id="try_write_lock-source">
            <pre><span class="ruby-comment"># File lib/concurrent/atomic/reentrant_read_write_lock.rb, line 308</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">try_write_lock</span>
  <span class="ruby-keyword">if</span> (<span class="ruby-identifier">held</span> = <span class="ruby-ivar">@HeldCount</span>.<span class="ruby-identifier">value</span>) <span class="ruby-operator">&gt;=</span> <span class="ruby-constant">WRITE_LOCK_HELD</span>
    <span class="ruby-ivar">@HeldCount</span>.<span class="ruby-identifier">value</span> = <span class="ruby-identifier">held</span> <span class="ruby-operator">+</span> <span class="ruby-constant">WRITE_LOCK_HELD</span>
    <span class="ruby-keyword">return</span> <span class="ruby-keyword">true</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">c</span> = <span class="ruby-ivar">@Counter</span>.<span class="ruby-identifier">value</span>
    <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">waiting_or_running_writer?</span>(<span class="ruby-identifier">c</span>) <span class="ruby-operator">&amp;&amp;</span>
       <span class="ruby-identifier">running_readers</span>(<span class="ruby-identifier">c</span>) <span class="ruby-operator">==</span> <span class="ruby-identifier">held</span> <span class="ruby-operator">&amp;&amp;</span>
       <span class="ruby-ivar">@Counter</span>.<span class="ruby-identifier">compare_and_set</span>(<span class="ruby-identifier">c</span>, <span class="ruby-identifier">c</span><span class="ruby-operator">+</span><span class="ruby-constant">RUNNING_WRITER</span>)
       <span class="ruby-ivar">@HeldCount</span>.<span class="ruby-identifier">value</span> = <span class="ruby-identifier">held</span> <span class="ruby-operator">+</span> <span class="ruby-constant">WRITE_LOCK_HELD</span>
      <span class="ruby-keyword">return</span> <span class="ruby-keyword">true</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">false</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- try_write_lock-source -->
          
        </div>

        

        
      </div><!-- try_write_lock-method -->

    
      <div id="method-i-with_read_lock" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">with_read_lock</span><span
            class="method-args">() { || ... }</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Execute a block operation within a read lock.</p>

<p>@yield the task to be performed within the lock.</p>

<p>@return [Object] the result of the block operation.</p>

<p>@raise [ArgumentError] when no block is given. @raise
[Concurrent::ResourceLimitError] if the maximum number of readers</p>

<pre>is exceeded.</pre>
          
          

          
          <div class="method-source-code" id="with_read_lock-source">
            <pre><span class="ruby-comment"># File lib/concurrent/atomic/reentrant_read_write_lock.rb, line 122</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">with_read_lock</span>
  <span class="ruby-identifier">raise</span> <span class="ruby-constant">ArgumentError</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&#39;no block given&#39;</span>) <span class="ruby-keyword">unless</span> <span class="ruby-identifier">block_given?</span>
  <span class="ruby-identifier">acquire_read_lock</span>
  <span class="ruby-keyword">begin</span>
    <span class="ruby-keyword">yield</span>
  <span class="ruby-keyword">ensure</span>
    <span class="ruby-identifier">release_read_lock</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- with_read_lock-source -->
          
        </div>

        

        
      </div><!-- with_read_lock-method -->

    
      <div id="method-i-with_write_lock" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">with_write_lock</span><span
            class="method-args">() { || ... }</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Execute a block operation within a write lock.</p>

<p>@yield the task to be performed within the lock.</p>

<p>@return [Object] the result of the block operation.</p>

<p>@raise [ArgumentError] when no block is given. @raise
[Concurrent::ResourceLimitError] if the maximum number of readers</p>

<pre>is exceeded.</pre>
          
          

          
          <div class="method-source-code" id="with_write_lock-source">
            <pre><span class="ruby-comment"># File lib/concurrent/atomic/reentrant_read_write_lock.rb, line 141</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">with_write_lock</span>
  <span class="ruby-identifier">raise</span> <span class="ruby-constant">ArgumentError</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&#39;no block given&#39;</span>) <span class="ruby-keyword">unless</span> <span class="ruby-identifier">block_given?</span>
  <span class="ruby-identifier">acquire_write_lock</span>
  <span class="ruby-keyword">begin</span>
    <span class="ruby-keyword">yield</span>
  <span class="ruby-keyword">ensure</span>
    <span class="ruby-identifier">release_write_lock</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- with_write_lock-source -->
          
        </div>

        

        
      </div><!-- with_write_lock-method -->

    
    </section><!-- public-instance-method-details -->
  
     <section id="private-instance-5Buntitled-5D-method-details" class="method-section section">
      <h3 class="section-header">Private Instance Methods</h3>

    
      <div id="method-i-max_readers-3F" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">max_readers?</span><span
            class="method-args">(c = @Counter.value)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>@!visibility private</p>
          
          

          
          <div class="method-source-code" id="max_readers-3F-source">
            <pre><span class="ruby-comment"># File lib/concurrent/atomic/reentrant_read_write_lock.rb, line 368</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">max_readers?</span>(<span class="ruby-identifier">c</span> = <span class="ruby-ivar">@Counter</span>.<span class="ruby-identifier">value</span>)
  (<span class="ruby-identifier">c</span> <span class="ruby-operator">&amp;</span> <span class="ruby-constant">MAX_READERS</span>) <span class="ruby-operator">==</span> <span class="ruby-constant">MAX_READERS</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- max_readers-3F-source -->
          
        </div>

        

        
      </div><!-- max_readers-3F-method -->

    
      <div id="method-i-max_writers-3F" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">max_writers?</span><span
            class="method-args">(c = @Counter.value)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>@!visibility private</p>
          
          

          
          <div class="method-source-code" id="max_writers-3F-source">
            <pre><span class="ruby-comment"># File lib/concurrent/atomic/reentrant_read_write_lock.rb, line 373</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">max_writers?</span>(<span class="ruby-identifier">c</span> = <span class="ruby-ivar">@Counter</span>.<span class="ruby-identifier">value</span>)
  (<span class="ruby-identifier">c</span> <span class="ruby-operator">&amp;</span> <span class="ruby-constant">MAX_WRITERS</span>) <span class="ruby-operator">==</span> <span class="ruby-constant">MAX_WRITERS</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- max_writers-3F-source -->
          
        </div>

        

        
      </div><!-- max_writers-3F-method -->

    
      <div id="method-i-running_readers" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">running_readers</span><span
            class="method-args">(c = @Counter.value)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>@!visibility private</p>
          
          

          
          <div class="method-source-code" id="running_readers-source">
            <pre><span class="ruby-comment"># File lib/concurrent/atomic/reentrant_read_write_lock.rb, line 343</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">running_readers</span>(<span class="ruby-identifier">c</span> = <span class="ruby-ivar">@Counter</span>.<span class="ruby-identifier">value</span>)
  <span class="ruby-identifier">c</span> <span class="ruby-operator">&amp;</span> <span class="ruby-constant">MAX_READERS</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- running_readers-source -->
          
        </div>

        

        
      </div><!-- running_readers-method -->

    
      <div id="method-i-running_readers-3F" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">running_readers?</span><span
            class="method-args">(c = @Counter.value)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>@!visibility private</p>
          
          

          
          <div class="method-source-code" id="running_readers-3F-source">
            <pre><span class="ruby-comment"># File lib/concurrent/atomic/reentrant_read_write_lock.rb, line 348</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">running_readers?</span>(<span class="ruby-identifier">c</span> = <span class="ruby-ivar">@Counter</span>.<span class="ruby-identifier">value</span>)
  (<span class="ruby-identifier">c</span> <span class="ruby-operator">&amp;</span> <span class="ruby-constant">MAX_READERS</span>) <span class="ruby-operator">&gt;</span> <span class="ruby-value">0</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- running_readers-3F-source -->
          
        </div>

        

        
      </div><!-- running_readers-3F-method -->

    
      <div id="method-i-running_writer-3F" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">running_writer?</span><span
            class="method-args">(c = @Counter.value)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>@!visibility private</p>
          
          

          
          <div class="method-source-code" id="running_writer-3F-source">
            <pre><span class="ruby-comment"># File lib/concurrent/atomic/reentrant_read_write_lock.rb, line 353</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">running_writer?</span>(<span class="ruby-identifier">c</span> = <span class="ruby-ivar">@Counter</span>.<span class="ruby-identifier">value</span>)
  <span class="ruby-identifier">c</span> <span class="ruby-operator">&gt;=</span> <span class="ruby-constant">RUNNING_WRITER</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- running_writer-3F-source -->
          
        </div>

        

        
      </div><!-- running_writer-3F-method -->

    
      <div id="method-i-waiting_or_running_writer-3F" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">waiting_or_running_writer?</span><span
            class="method-args">(c = @Counter.value)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>@!visibility private</p>
          
          

          
          <div class="method-source-code" id="waiting_or_running_writer-3F-source">
            <pre><span class="ruby-comment"># File lib/concurrent/atomic/reentrant_read_write_lock.rb, line 363</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">waiting_or_running_writer?</span>(<span class="ruby-identifier">c</span> = <span class="ruby-ivar">@Counter</span>.<span class="ruby-identifier">value</span>)
  <span class="ruby-identifier">c</span> <span class="ruby-operator">&gt;=</span> <span class="ruby-constant">WAITING_WRITER</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- waiting_or_running_writer-3F-source -->
          
        </div>

        

        
      </div><!-- waiting_or_running_writer-3F-method -->

    
      <div id="method-i-waiting_writers" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">waiting_writers</span><span
            class="method-args">(c = @Counter.value)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>@!visibility private</p>
          
          

          
          <div class="method-source-code" id="waiting_writers-source">
            <pre><span class="ruby-comment"># File lib/concurrent/atomic/reentrant_read_write_lock.rb, line 358</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">waiting_writers</span>(<span class="ruby-identifier">c</span> = <span class="ruby-ivar">@Counter</span>.<span class="ruby-identifier">value</span>)
  (<span class="ruby-identifier">c</span> <span class="ruby-operator">&amp;</span> <span class="ruby-constant">MAX_WRITERS</span>) <span class="ruby-operator">&gt;&gt;</span> <span class="ruby-constant">READER_BITS</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- waiting_writers-source -->
          
        </div>

        

        
      </div><!-- waiting_writers-method -->

    
    </section><!-- private-instance-method-details -->
  
  </section><!-- 5Buntitled-5D -->

</div><!-- documentation -->


<footer id="validator-badges">
  <p><a href="http://validator.w3.org/check/referer">[Validate]</a>
  <p>Generated by <a href="https://github.com/rdoc/rdoc">RDoc</a> 4.0.0.
  <p>Generated with the <a href="http://deveiate.org/projects/Darkfish-Rdoc/">Darkfish Rdoc Generator</a> 3.
</footer>

